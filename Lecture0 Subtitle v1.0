1
00:00:50,190 --> 00:00:53,565
这里是CS50 哈佛大学
This is CS50, Harvard University's introduction

2
00:00:53,566 --> 00:00:55,891
计算机科学和编程艺术的
to the intellectual enterprises of computer science

3
00:00:55,892 --> 00:00:57,203
入门课程
and the art of programming.

4
00:00:57,204 --> 00:00:58,541
我叫David Malan
My name is David Malan,

5
00:00:58,542 --> 00:01:01,630
在座的你如果在想
and if you are among those in the room who are thinking,

6
00:01:01,631 --> 00:01:03,795
我怎么会在计算机科学的课上
why am I in a class of computer science,

7
00:01:03,796 --> 00:01:06,359
你要知道 我也是这么想的
realize that I too felt that exact same way.

8
00:01:06,360 --> 00:01:08,739
其实我大一的时候 还没有勇气
In fact, my freshman year, I didn't quite get up the nerve

9
00:01:08,740 --> 00:01:11,323
选这门课 或者其他计算机科学的课
to take this class or computer science more generally,

10
00:01:11,324 --> 00:01:13,929
很大程度上是因为我被吓怕了
and that was largely because I was intimidated by it.

11
00:01:13,930 --> 00:01:15,203
我有点紧张
I was a little nervous.

12
00:01:15,204 --> 00:01:17,017
这远远超出了我的舒适区
It felt well out of my comfort zone.

13
00:01:17,018 --> 00:01:20,440
我完全不知道这到底是什么
And I really didn't know at the end of the day what it actually was.

14
00:01:20,441 --> 00:01:22,832
但你要知道 假如你也有这种感觉
But realize if you, too, are feeling a little bit of that,

15
00:01:22,833 --> 00:01:24,562
或者说你之前接触过计算机科学或编程
or even if you're among those more comfortable

16
00:01:24,563 --> 00:01:26,773
现在感觉还可以
who have dabbled in computer science or programming,

17
00:01:26,774 --> 00:01:29,720
你都要知道 我们还可以填补很多的空白
realize that there's so many blanks that we can fill in along the way

18
00:01:29,721 --> 00:01:31,289
所以最后到了学期末
so that ultimately, at the end of the semester,

19
00:01:31,290 --> 00:01:34,795
大家都会觉得彼此步调是一致的
everyone will feel themselves on the same page.

20
00:01:34,796 --> 00:01:38,515
在那之前 你们放心
And until then, rest assured that 68% of the people

21
00:01:38,516 --> 00:01:41,297
你前后左右这些座位上有68%的人
sitting to your left and to your right and behind and in front

22
00:01:41,298 --> 00:01:44,301
从没上过计算机科学的课
have never taken a CS course before,

23
00:01:44,302 --> 00:01:47,571
你很可能就是他们之中的一个
which may very well be the demographic into which you fit.

24
00:01:47,572 --> 00:01:51,352
但你要知道 我们有这么出色的支持体系
But realize, too, that with such an amazing support structure

25
00:01:51,353 --> 00:01:54,472
安排了这么多办公时间 板块 材料等等
with so many office hours and sections and materials and beyond,

26
00:01:54,473 --> 00:01:56,751
这门课到头来最重要的
realize that what's ultimately important in this course

27
00:01:56,752 --> 00:02:00,701
不是最后第10周时你和同班同学相比是什么水平
is not so much where you end up relative to your classmates in week 10,

28
00:02:00,702 --> 00:02:04,969
而是你和第0周的自己相比是什么水平
our final week, but where you end up relative to yourself in week zero.

29
00:02:04,970 --> 00:02:06,686
我们现在正处在第0周
And indeed, that is where we now are.

30
00:02:06,687 --> 00:02:09,325
而事实上 计算机科学家也是从0开始计数的
And as it turns out, computer scientists start counting at zero.

31
00:02:09,326 --> 00:02:12,249
那么在接下里的11周里 我们会引领你
And so over the next 11 weeks, we will take you

32
00:02:12,250 --> 00:02:14,179
从感觉不好
from being among those less comfortable

33
00:02:14,180 --> 00:02:16,678
或者感觉在好与不好之间的状态
or perhaps somewhere in between less comfortable and more

34
00:02:16,679 --> 00:02:21,070
到感觉更好 更自信 更有能力
to feeling much more comfortable and confident and capable than that.

35
00:02:21,071 --> 00:02:24,633
但要做到如此 我们首先要明白计算机科学究竟是什么
But to get there, we need to understand what computer science really is.

36
00:02:24,636 --> 00:02:28,006
这个问题 在踏入这样的房间之前我并不明白
And this was something I didn't understand until I set foot in a room like this.

37
00:02:28,007 --> 00:02:31,712
这种情形很适合解释计算机科学
And I dare say we can distill computer science into just this picture.

38
00:02:31,713 --> 00:02:33,795
计算机科学是解决问题的科学
Computer science is about problem solving.

39
00:02:33,796 --> 00:02:36,915
我知道 高中课程通常误导学生
And I know that high school courses typically do kind of paint

40
00:02:36,916 --> 00:02:38,814
让学生以为计算机科学
a misleading picture that it's only about

41
00:02:38,815 --> 00:02:40,519
完全是编程
and it's entirely about programming

42
00:02:40,520 --> 00:02:42,688
人们在计算机实验室埋头苦干
and people with their heads down in the computer lab

43
00:02:42,689 --> 00:02:44,894
专心写代码 不与人交往
working fairly anti-socially on code,

44
00:02:44,895 --> 00:02:47,181
但实际上计算机科学是用来解决问题的
but the reality is it's all about solving problems,

45
00:02:47,182 --> 00:02:49,480
并且通常是以合作的形式解决问题
and very often, solving problems collaboratively

46
00:02:49,481 --> 00:02:51,720
亲自解决或利用前人已经写好的
either in person or by leveraging code,

47
00:02:51,721 --> 00:02:53,744
程序或代码
programs that others have written in the past.

48
00:02:53,745 --> 00:02:55,512
那么解决问题是什么意思
And what does it mean to solve a problem?

49
00:02:55,513 --> 00:02:57,279
你需要输入
Well, you need inputs.

50
00:02:57,280 --> 00:02:58,823
你有一个要解决的问题
So there's a problem you're trying to solve.

51
00:02:58,824 --> 00:02:59,796
这就是输入
That is the input.

52
00:02:59,797 --> 00:03:00,564
你想要的是输出
And you want output.

53
00:03:00,565 --> 00:03:02,211
就是问题的解决方法
You want the solution to that problem.

54
00:03:02,212 --> 00:03:04,339
计算机科学的秘密武器
And the sort of secret sauce of computer science

55
00:03:04,340 --> 00:03:07,700
就是我们要在接下来几周讨论的
is going to be everything in this proverbial black box in the middle

56
00:03:07,704 --> 00:03:09,015
眼前的这个黑箱里的内容
over the next several weeks,

57
00:03:09,016 --> 00:03:12,531
从此你就能开始理解你能用它做什么
where you begin to understand exactly what you can do with that.

58
00:03:12,532 --> 00:03:15,059
但在开始解决问题之前
But in order to start solving problems,

59
00:03:15,060 --> 00:03:16,799
我们作为一个团队 需要决定
we kind of just need to decide as a group

60
00:03:16,800 --> 00:03:18,792
我们应如何表示这些问题
how we're going to represent these problems

61
00:03:18,793 --> 00:03:20,284
可能的问题是什么
and what might a problem be.

62
00:03:20,285 --> 00:03:21,993
在这个房间里 有一大群人
Well, in this room, there's a whole bunch of people.

63
00:03:21,996 --> 00:03:25,147
如果我们要记考勤 或者点人数
If we wanted to take attendance or count the number of people in this room,

64
00:03:25,148 --> 00:03:28,586
我就要记下我看到的人数
I might need to start keeping track of how many people I see.

65
00:03:28,587 --> 00:03:31,261
但我要怎么表示我看到的人数呢
But how do I represent the number of people I see?

66
00:03:31,262 --> 00:03:32,691
我可以用传统的办法
Well, I can do it sort of old school

67
00:03:32,692 --> 00:03:35,206
拿一根粉笔或类似的东西
and I can just take out a piece of chalk or whatnot

68
00:03:35,207 --> 00:03:38,931
这样记人数 1 2 3 4 5
and say, all right, I see 1, 2, 3, 4, 5.

69
00:03:38,932 --> 00:03:40,825
或者用其他通用的计数图案
I can do little stylistic conventions like that

70
00:03:40,826 --> 00:03:42,134
来节约空间并且提醒自己
to save space and remind myself.

71
00:03:42,135 --> 00:03:46,291
6 7 8 9 10等等
6, 7, 8, 9, 10, and so forth.

72
00:03:46,292 --> 00:03:49,419
或者我还可以用我的手
Or I can, of course, just do that on my own hand.

73
00:03:49,420 --> 00:03:53,292
1 2 3 4 5 像这样
So 1, 2, 3, 4, 5, and so forth.

74
00:03:53,293 --> 00:03:56,497
但很明显 我用一只手能数到多少呢
But obviously, how high can I count on just one hand?

75
00:03:57,970 --> 00:03:59,459
你可能觉得是5
So 5 you would think,

76
00:03:59,460 --> 00:04:00,723
因为我们对这个问题
but that's just because we haven't really

77
00:04:00,726 --> 00:04:02,255
思考得还不够
thought hard enough about this problem.

78
00:04:02,256 --> 00:04:05,393
其实 只用这五根手指 不管另外五根
It turns out that with just these five fingers, let alone these five more,

79
00:04:05,394 --> 00:04:07,633
我也能数到很大的数字
I can actually count rather higher

80
00:04:07,634 --> 00:04:10,560
因为我在黑板上画斜杠
because after all, the system I'm using of hashmarks on the board

81
00:04:10,563 --> 00:04:13,649
或者是用手指的方法 其实只是利用
or just now with my fingers is just kind of keeping my fingers down

82
00:04:13,650 --> 00:04:16,730
手指竖起或放下来表示个数
or putting them up to represent ones, really.

83
00:04:16,733 --> 00:04:19,832
假如我考虑手指的顺序
But what if I actually took into account the order of my fingers

84
00:04:19,833 --> 00:04:21,695
对它们进行排列
and sort of permuted them, so to speak,

85
00:04:21,696 --> 00:04:23,821
也就是用手指的模式
so that it's really patterns of fingers

86
00:04:23,822 --> 00:04:25,415
来表示房间里的人数
that represent the number of people in the room,

87
00:04:25,416 --> 00:04:28,090
不仅仅是一根手指竖起或放下
and not just the mere presence of a finger going up or down.

88
00:04:28,093 --> 00:04:29,986
换句话说 这依旧表示0
In other words, this can remain zero.

89
00:04:29,987 --> 00:04:31,654
这依旧表示1
This could still be one.

90
00:04:31,655 --> 00:04:34,776
假如2不用这种明显的方式表示
But what if two is not just this, the obvious?

91
00:04:34,777 --> 00:04:36,715
假如2是这样
But what if it's just this?

92
00:04:36,716 --> 00:04:39,172
只竖1根食指
So raising just one, my second finger.

93
00:04:39,175 --> 00:04:41,709
那么3就是这样
What if, then, three is this?

94
00:04:41,710 --> 00:04:44,979
我们就有了0 1 2 3
So we have 0, 1, 2, 3.

95
00:04:44,980 --> 00:04:47,689
这样4的手势就有些冒犯了
That's going to lead us to four somewhat offensively.

96
00:04:47,690 --> 00:04:50,845
那我们跳到5
But if we begin to jump ahead to five,

97
00:04:51,240 --> 00:04:53,353
我就可以把这根手指和这根手指竖起来
I might now permute this finger and this finger up.

98
00:04:53,356 --> 00:04:56,621
我要是想表示6 那就这样
And if I want to now represent six, I could do this.

99
00:04:56,622 --> 00:04:57,504
然后是7
And now seven.

100
00:04:57,505 --> 00:05:00,410
这样看来 我已经在手上变出许多种花样了
In other words, I've expressed so many more patterns on my hand already

101
00:05:00,413 --> 00:05:02,316
继续下去 我们就能
and if we keep doing this, I think I can actually

102
00:05:02,317 --> 00:05:06,880
变幻出32种花样
represent painfully perhaps like 32 different patterns,

103
00:05:06,886 --> 00:05:10,035
也就是我的手可以表示32个不同的人
and therefore 32 different people, on my hands alone.

104
00:05:10,036 --> 00:05:12,225
或者从0开始数的话 就是31个人
Or 31 people if I start counting at zero.

105
00:05:12,226 --> 00:05:14,444
那么这是什么 这之间是什么关系
So what is that... what's the relationship

106
00:05:14,445 --> 00:05:15,533
我们是怎么做到的
and how did we even get here?

107
00:05:15,534 --> 00:05:18,346
事实上 计算机运作非常简单
Well, it turns out that computers are kind of simplistic,

108
00:05:18,347 --> 00:05:19,760
就像我们的手一样
much like our hands here.

109
00:05:19,763 --> 00:05:22,069
到头来 你的计算机在墙上插着
At the end of the day, your computer is plugged into the wall

110
00:05:22,070 --> 00:05:25,564
或者用电池 所以它要么有电 要么没有
or it's got a battery, so it either has or it does not have electricity.

111
00:05:25,565 --> 00:05:27,239
到头来 都是物理资源
At the end of the day, that is the physical resource

112
00:05:27,240 --> 00:05:30,480
在促使我们的手机等科技完成任务
that drives these things and our phones and all of technology today.

113
00:05:30,483 --> 00:05:33,134
所以是否有电
So if there is either electricity or not,

114
00:05:33,135 --> 00:05:36,306
就类似于有手指或没手指
that kind of maps nicely to no finger or yes finger.

115
00:05:36,307 --> 00:05:39,873
你们应该知道 计算器说的唯一一种语言是什么
And indeed, computers, as you probably know, only speak what language?

116
00:05:39,874 --> 00:05:41,398
什么字母表
What alphabet, so to speak?

117
00:05:41,787 --> 00:05:42,606
对 二进制
Yeah. Binary.

118
00:05:42,607 --> 00:05:43,509
Bi的意思就是2
Bi meaning two.

119
00:05:43,510 --> 00:05:46,695
意思就是 计算机二进制中
And indeed, that refers to the fact that in binary in computers,

120
00:05:46,696 --> 00:05:49,710
只有2个数字 0和1
you only have two digits... zero and one.

121
00:05:49,711 --> 00:05:53,843
我们人类自然有0 1 2 3 4 5 6 7 8 9
We humans, of course, have 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,

122
00:05:53,846 --> 00:05:56,000
我们还可以结合它们形成更大的数字
and then we can combine those to count even higher.

123
00:05:56,003 --> 00:05:59,112
但计算机只有0和1 就没了
But computers only have 0, 1, and then that's it.

124
00:05:59,113 --> 00:06:01,209
但到头来 其实它们之间的关系很直接
Because at the end of the day, there's actually a direct mapping

125
00:06:01,210 --> 00:06:03,794
0代表没有通电
between power being off and it being a zero

126
00:06:03,795 --> 00:06:05,582
1代表通电
or power being on and it being one,

127
00:06:05,586 --> 00:06:09,428
或者说电子之类的东西从电池或墙上流出
or some electrons or whatever flowing from your battery or from the wall.

128
00:06:09,429 --> 00:06:12,809
所以电脑只使用二进制
So this is why computers tend to speak only binary,

129
00:06:12,810 --> 00:06:15,280
因为到头来 它清楚地指向
because at the end of the day, it just maps really cleanly

130
00:06:15,283 --> 00:06:18,885
给它们供能的东西
to what it is that's powering them in the first place.

131
00:06:18,886 --> 00:06:20,625
但这真的有用吗
But how is this actually useful?

132
00:06:20,626 --> 00:06:23,795
假如计算机只有0和1 它们怎么起作用呢
If computers only have zeros and ones, how can they do anything useful?

133
00:06:23,796 --> 00:06:26,066
想一想我们的人类世界
Well, think about our human world,

134
00:06:26,067 --> 00:06:28,468
你可以从中找到这种模式的标志
where you might have this pattern of symbols.

135
00:06:28,469 --> 00:06:31,555
这是十进制 dec指10 从0到9
This is decimal, dec meaning 10 because you have 0 through 9.

136
00:06:31,556 --> 00:06:33,800
这是1 2 3
And this is, of course, 123.

137
00:06:33,801 --> 00:06:34,560
可是为什么呢
But why?

138
00:06:34,566 --> 00:06:36,844
你可能没怎么想过这个问题
If you haven't thought about this in quite some time,

139
00:06:36,845 --> 00:06:40,315
这就是3中标志的花样 1 2 3
this is really just a pattern of three symbols, one and two and three

140
00:06:40,316 --> 00:06:42,072
在屏幕上的形状或字符
shapes, or glyphs, on the screen.

141
00:06:42,073 --> 00:06:44,073
但我们人类 自从小学
But we humans, ever since grade school,

142
00:06:44,076 --> 00:06:46,860
就开始给这些数字附加意义 对吗
have started ascribing meaning to each of these numbers, right?

143
00:06:46,862 --> 00:06:50,301
你回过头想想 这是个位 这是十位
If you think back, this is the ones column, this is the tens column,

144
00:06:50,302 --> 00:06:51,967
这是百位
this is the hundreds column,

145
00:06:51,968 --> 00:06:53,825
这样我们就能一直数下去
and so forth, and we could keep going.

146
00:06:53,826 --> 00:06:57,971
那为什么这种1 2 3的花样意思是123呢
And so why does this pattern... one, two, three... mean 123?

147
00:06:57,972 --> 00:07:00,765
因为我们现在都本能地
Well, it's because all of us sort of intuitively nowadays

148
00:07:00,766 --> 00:07:04,461
在脑子里计算 100乘1
are just quickly in our head doing 100 times 1

149
00:07:04,462 --> 00:07:08,069
加上10乘2和1乘3
plus 10 times 2 plus 1 times 3,

150
00:07:08,070 --> 00:07:11,922
也就是100加20加3
which of course gives us 100 plus 20 plus three,

151
00:07:11,923 --> 00:07:15,822
这个数字就是123
and then the number we know mathematically as 123.

152
00:07:15,826 --> 00:07:19,033
我们很快就这样反应 根本不加思考
But we're all doing this so quickly, you don't really think about this anymore.

153
00:07:19,036 --> 00:07:21,433
计算机工作原理也一样
Well, computers work fundamentally the same way.

154
00:07:21,434 --> 00:07:24,546
它们跟我们不一样 没有0到9这么多数字
They don't have as many digits... 0 through 9... as we do.

155
00:07:24,547 --> 00:07:26,502
它们只有0和1
They only have zeros and ones.

156
00:07:26,503 --> 00:07:28,699
所以如果它们要储存信息
And so if they were to store values,

157
00:07:28,700 --> 00:07:30,357
屏幕上就只有0和1
you're only going to see zeros and ones on the screen,

158
00:07:30,358 --> 00:07:32,469
但那些0和1的意思是不一样的
but those zeros and ones just mean different things.

159
00:07:32,470 --> 00:07:35,029
它们没有个位 十位 百位
Instead of having a ones place, tens, a hundreds,

160
00:07:35,030 --> 00:07:39,720
而是个位 二位 四位
they're going to have a ones place, a twos place, a fours place,

161
00:07:39,721 --> 00:07:41,840
八位 十六位
and then eights and 16 and beyond.

162
00:07:41,843 --> 00:07:42,594
那么为什么呢
Now, why?

163
00:07:42,598 --> 00:07:46,819
1 10 100都是10的幂
Well, one and 10 and 100, turns out those are powers of 10.

164
00:07:46,820 --> 00:07:49,299
10的0次幂是1
10 to the 0 is technically 1.

165
00:07:49,300 --> 00:07:50,930
10的1次幂是10
10 to the 1 is just 10.

166
00:07:50,932 --> 00:07:52,280
10的2次幂是100
10 to the 2 is 100.

167
00:07:52,285 --> 00:07:55,679
所以我们会有1 10 100 1000等等
And that's why you have ones, tens, hundreds, thousands, and so forth.

168
00:07:55,680 --> 00:07:58,270
计算机用的是2的幂
Computers are apparently using powers of 2.

169
00:07:58,271 --> 00:07:59,033
不奇怪吧
Not surprising.

170
00:07:59,034 --> 00:08:00,114
二进制 2
Binary... two.

171
00:08:00,115 --> 00:08:04,909
假如你只有1 2 4作为占位符
So if you only have ones, twos, and fours as your placeholders,

172
00:08:04,910 --> 00:08:10,229
计算机储存这些数字 0 0 0
if a computer were storing these digits... 0, 0, 0

173
00:08:10,230 --> 00:08:14,897
它是在储存我们理解的什么数字呢
that computer is presumably storing what number so far as we humans understand it?

174
00:08:15,318 --> 00:08:17,067
这就是计算机储存0的方式
Well, that's how a computer would store zero.

175
00:08:17,068 --> 00:08:20,111
如果计算机储存0 0 0
If a computer is storing literally 0, 0, 0,

176
00:08:20,114 --> 00:08:22,312
这跟我们的用法一样 也是0
just like in our human world, that also is 0,

177
00:08:22,313 --> 00:08:26,720
但严格来说 这是因为0的0次幂加2次幂加1次幂
but that's technically because it's 4 times 0 plus 2 times 0 plus 1 times zero,

178
00:08:26,723 --> 00:08:28,099
显然是0
which is obviously zero.

179
00:08:28,100 --> 00:08:31,509
同时 如果计算机存储的是不仅是0 0 0
Meanwhile, if a computer is actually storing not just,

180
00:08:31,510 --> 00:08:36,291
这样的数值 而是用二进制储存信息
say, 0, 0, 0, but instead is storing this value in binary,

181
00:08:36,292 --> 00:08:38,299
它在十进制中是多少呢
what does that map to in decimal?

182
00:08:38,747 --> 00:08:39,634
这是1
So that's one.

183
00:08:39,635 --> 00:08:47,209
那如果我们把这里的0和1换掉 不就是2了吗
And now, why, if we change this 0 and 1 to this value here, is this two?

184
00:08:47,210 --> 00:08:49,432
数学上也是一样的道理
Well, mathematically, for the exact same reasons.

185
00:08:49,433 --> 00:08:52,812
之前我有5根手指 如果你注意到我的前3根
And so earlier, I had five fingers, but if you consider just my first three,

186
00:08:52,813 --> 00:08:56,812
我竖这一根手指 就表示2
when I did this holding up one finger, I was representing two.

187
00:08:56,813 --> 00:09:00,054
我要是想表示3 别忘了我还竖着第二根手指
And if I want to represent three, recall that I put up the second finger.

188
00:09:00,055 --> 00:09:03,289
我们能表示3
And so the reason that could nicely represent three

189
00:09:03,290 --> 00:09:07,859
是因为我在手上使用了二进制
is because all I was doing with my human hand was counting in binary.

190
00:09:07,860 --> 00:09:09,721
我可以一直数下去
And I could keep counting more and more and more.

191
00:09:09,725 --> 00:09:14,722
我有5根手指 或者说5个比特 比特就是二进制
And so if I have five fingers or five bits, bit meaning binary digits,

192
00:09:14,723 --> 00:09:16,720
用数学方法算一下 从0开始
I could count up, it turns out, if we do the math,

193
00:09:16,723 --> 00:09:19,880
我可以数到31
as high as 31 by starting to zero.

194
00:09:19,881 --> 00:09:23,042
这样从生理上来说有点难 但我们可以
It's going to be hard to physically do that, but we could.

195
00:09:23,043 --> 00:09:24,910
为什么这很有用呢
So why is this useful?

196
00:09:24,911 --> 00:09:26,739
到头来 计算机
At the end of the day, a computer, therefore,

197
00:09:26,740 --> 00:09:30,123
可以表示任何数字从0到1到2到3
can represent any number of values from 0 to 1 to 2 to 3

198
00:09:30,124 --> 00:09:32,494
表示的数字非常非常非常大的
to some number much, much, much higher than that.

199
00:09:32,495 --> 00:09:35,244
我只需要足够的比特 足够的0和1
All it needs is enough bits, enough zeros and ones.

200
00:09:35,245 --> 00:09:36,475
这些比特是什么东西
Well, what are those bits?

201
00:09:36,476 --> 00:09:40,628
我们的手机现在都有灯源
Well, all of us have these days in our phones sources of light, for instance.

202
00:09:40,629 --> 00:09:43,539
可以说 这个物理设备
So I could actually say that this physical device right now...

203
00:09:43,540 --> 00:09:44,817
可能有点难判断
might be a little hard to tell...

204
00:09:44,818 --> 00:09:47,894
它有闪光灯 现在是关闭的
it does have a flashlight and it's technically off at the moment.

205
00:09:47,895 --> 00:09:51,512
但如果我把闪光灯打开 就会用电
But if I turn this flashlight on, thereby using some of the electricity,

206
00:09:51,513 --> 00:09:53,383
现在我要储存1
now, I'm storing a one.

207
00:09:53,384 --> 00:09:54,482
手机就亮了
And so the phone is on.

208
00:09:54,483 --> 00:09:55,385
这样就关了
Now, it's off.

209
00:09:55,386 --> 00:09:56,125
亮了
Now, it's on.

210
00:09:56,126 --> 00:09:57,285
让我看看
And if I see...

211
00:09:57,286 --> 00:09:59,689
我能不能借谁的手机用一下 一下就好
can I borrow someone's phone real quick? May I?

212
00:09:59,690 --> 00:10:00,180
好
OK.

213
00:10:00,184 --> 00:10:01,699
要开闪光灯
And flashlight.

214
00:10:01,700 --> 00:10:03,102
闪光灯怎么打开
How do I turn on the flashlight?

215
00:10:03,422 --> 00:10:04,806
摇晃手机
Oh. Shake it.

216
00:10:07,391 --> 00:10:08,062
好了
That's OK.

217
00:10:08,063 --> 00:10:09,189
好 谢谢
OK. Thank you.

218
00:10:09,190 --> 00:10:10,180
这就像
Oh. That's like a...

219
00:10:10,184 --> 00:10:11,283
谢谢
Thank you. OK.

220
00:10:11,286 --> 00:10:11,864
太棒了
So this is great.

221
00:10:11,864 --> 00:10:12,713
我现在可以数更多数字了
Now, I can count higher.

222
00:10:12,714 --> 00:10:16,200
那么我要是有两个灯泡
Now, this represents the number what

223
00:10:16,201 --> 00:10:19,502
两个开关 那这代表什么数字
if I have two light bulbs or two switches on at the moment?

224
00:10:19,871 --> 00:10:20,556
3
Yeah. Three.

225
00:10:20,557 --> 00:10:23,171
因为我有了1个 2个
Because I have a one, I have a one, and I have two,

226
00:10:23,172 --> 00:10:24,775
那肯定要来第3个
which of course is going to end up equaling three.

227
00:10:24,776 --> 00:10:27,682
假如我再拿第3个手机 我就可以数出更大的数字
And if I pick up a third phone somehow, I could count even higher.

228
00:10:27,683 --> 00:10:30,138
严格来说 如果我有三个灯泡...
Technically, if I had three light bulbs on...

229
00:10:30,139 --> 00:10:32,793
1 1 1 那个值会是多少
one, one, one... what would that value be?

230
00:10:33,053 --> 00:10:33,394
7
Seven.

231
00:10:33,395 --> 00:10:36,456
因为是4加2加1 以此类推
Because it's a four plus a two plus a one, and so forth.

232
00:10:36,457 --> 00:10:38,430
非常感谢这一自发性
Thank you so much for the spontaneity.

233
00:10:38,431 --> 00:10:43,421
那么为什么这个又并没给我们带来限制呢
So why does this not lead to limitations for us?

234
00:10:43,422 --> 00:10:45,682
十进制数我可以按我所想一直数下去
I can count in decimal as high as I want.

235
00:10:45,683 --> 00:10:49,081
现在我也可以这样计数二进制数 只要我有足够多的位
I can now count in binary as high as I want, so long as I have enough bits.

236
00:10:49,085 --> 00:10:52,760
可我该如何真正表征其他信息呢
But how do I actually represent other information?

237
00:10:52,761 --> 00:10:57,200
比方说如果我想表示一个字母 该怎么操作
Well, if I want to represent something like a letter, how do I get there?

238
00:10:57,749 --> 00:11:02,057
如果电脑只是通了电 而且用二进制计数
If computers only have electricity in them and they use binary to count,

239
00:11:02,058 --> 00:11:04,865
此外某种程度上它们的用途远不止做数学
and yet somehow they're much more useful than just doing math...

240
00:11:04,866 --> 00:11:08,570
它们可以提供文本信息 电子邮件 网页以及视频服务等等之类
they can have text messages and e-mails and websites and videos and more...

241
00:11:08,573 --> 00:11:11,647
那么我们如何从那些0和1得到许多字母
how do we get from zeros and ones to letters?

242
00:11:11,648 --> 00:11:13,193
嗯好 我们... 你请讲
Well, we... yeah.

243
00:11:15,820 --> 00:11:17,095
不好意思 请大点儿声
Sorry. A little louder.

244
00:11:18,678 --> 00:11:19,177
是的
Yeah.

245
00:11:19,178 --> 00:11:21,185
我们只需要做类似于把数字与字母对应起来的事情
We just need to kind of relate the numbers to letters.

246
00:11:21,186 --> 00:11:24,080
换言之 在座的各位只需要在某些关键点问题上做出决定
In other words, all the people in this room just need to decide at some point

247
00:11:24,083 --> 00:11:24,946
也就是 你知道吗
that, you know what?

248
00:11:24,947 --> 00:11:27,721
假设我们想表示大写字母A
If we want to represent something like the capital letter A,

249
00:11:27,725 --> 00:11:29,666
我们只需认真考虑并决定出二进制位的呈现方式
we just need to decide on a pattern of bits,

250
00:11:29,667 --> 00:11:32,499
这里打算用手指的形式来表示A
a pattern of fingers, that's going to represent A.

251
00:11:32,500 --> 00:11:34,395
最终在数年之前的人们
And it turns out humans years ago

252
00:11:34,396 --> 00:11:35,757
仅仅单方面地决定
just unilaterally decided

253
00:11:35,758 --> 00:11:40,472
65是代表大写字母A的十进制数
65 shall be the decimal number that represents capital letter A.

254
00:11:40,473 --> 00:11:44,003
接着你会揣摩那大写字母B用什么十进制数表示
And you might guess capital B is represented by what decimal number?

255
00:11:44,257 --> 00:11:44,977
66
66.

256
00:11:44,978 --> 00:11:46,925
然后大写字母C用67 依此类推
And then C is 67 and so forth.

257
00:11:46,926 --> 00:11:51,209
于是这就会存在一个含有128甚至256个可能数值的映射
And there's a mapping of like 128 or even 256 possible values

258
00:11:51,210 --> 00:11:53,390
对于标准键盘上可见到的所有按键
for all the keys you might see on a typical keyboard

259
00:11:53,391 --> 00:11:55,202
为了呈现这些字母
in order to represent letters.

260
00:11:55,203 --> 00:11:58,802
现在 即便如此 电脑是如何区分数字与字母的呢
Now, how does a computer distinguish, though, numbers from letters?

261
00:11:58,803 --> 00:12:00,212
其实只须基于上下文
Well, just depends on the context.

262
00:12:00,215 --> 00:12:02,440
比方说如果你正在Mac上使用计算器程序
If you're using like a calculator program on your Mac

263
00:12:02,441 --> 00:12:06,104
或者PC机 或者iPhone 或者Android 总之 电脑以及设备
or PC or iPhone or Android, well, the computer, the device,

264
00:12:06,105 --> 00:12:07,929
就是打算联系上下文获取信息
is just going to know contextually,

265
00:12:07,930 --> 00:12:09,947
让我来阐释下这些0和1的形式
let me interpret this pattern of zeros and ones

266
00:12:09,948 --> 00:12:11,885
当它们作为真正的数字来做数学运算
as actual numbers to do math.

267
00:12:11,886 --> 00:12:15,299
但如果你正在使用你手机上的短信APP或者通讯APP
But if you're using the SMS app or the messages app on your phone,

268
00:12:15,300 --> 00:12:17,558
你就即将真正置身于信息文本的语义语境之中
you're going to actually be in the context of text,

269
00:12:17,559 --> 00:12:20,936
因此你的手机也将解释这些0和1的存在模式
and so your phone is going to interpret that same pattern of zeros and ones,

270
00:12:20,937 --> 00:12:24,365
或者灯泡熄灭 又或者一天结束了 那些晶体管
or light bulbs being off, or, at the end of the day, transistors,

271
00:12:24,366 --> 00:12:27,859
硬件的那些小零部件以及电脑 是非开即关的二元状态
tiny pieces of hardware and computers that are either on or off...

272
00:12:27,860 --> 00:12:31,134
阐释这些二元模式就正如表征一个字母那样
it's going to interpret those patterns as just representing a letter.

273
00:12:31,135 --> 00:12:34,774
假如你处于一个文本通讯应用或者微软word的环境里
If you're in the context of a text messaging application or Microsoft Word

274
00:12:34,775 --> 00:12:38,702
也或者Google Docs诸如此类 这就完全取决于上下文
or Google Docs or the like, it completely depends on context.

275
00:12:38,706 --> 00:12:41,254
而我们人类构想出了一个ASCII体系
The system we humans came up with just called ASCII,

276
00:12:41,255 --> 00:12:43,644
全称是American Standard Code for Information Interchange
American Standard Code for Information Interchange.

277
00:12:43,645 --> 00:12:47,264
名称并不有趣 但重点是在多年前我们就一致同意
The name isn't interesting, but the fact that we all agreed years ago

278
00:12:47,265 --> 00:12:50,723
65代表大写字母A 并依此类推 这才是关键
that 65 is A and so forth is what's important.

279
00:12:50,726 --> 00:12:53,454
举个例子 我们来看这个映射
And so for instance, if we look at this mapping here

280
00:12:53,455 --> 00:12:56,754
当中的前几个字母 思考下这个意味着什么
of just the first few letters, what does this mean?

281
00:12:56,755 --> 00:13:00,049
假设我有这样一则文本信息
If I were to now get a text message

282
00:13:00,050 --> 00:13:03,011
某种意义上我曾有格物致知的本领 所以来谈谈
I had the ability somehow to look underneath the hood, so to speak,

283
00:13:03,012 --> 00:13:04,734
0和1的模式
at the pattern of zeros and ones

284
00:13:04,735 --> 00:13:07,390
比方某人刚给我发过信息 那么按那个模式
that someone had just texted me, and that pattern,

285
00:13:07,391 --> 00:13:12,764
我把它转换成十进制 技术性地讲 我接收的信息十进制数是72和73...
if I convert it to decimal, technically said, let's say, 72 and 73...

286
00:13:12,765 --> 00:13:14,472
于是我获取了一大堆0和1
so I get a whole bunch of zeros and ones.

287
00:13:14,473 --> 00:13:18,031
我通过数学运算证实了我刚收到的是72和73
I do some math and I realize, OK, I just received 72 and 73,

288
00:13:18,034 --> 00:13:21,212
但这可是文本信息啊 所以我朋友发给我的绝不仅仅是数
but this is texting, and so it's not just numbers my friend is sending me.

289
00:13:21,213 --> 00:13:22,080
是一条消息
It's a message.

290
00:13:22,086 --> 00:13:28,006
72然后73这说明我朋友给我发的消息很可能是什么呢
What message did my friend likely send me if he or she sent 72 and then 73?

291
00:13:28,626 --> 00:13:29,370
对，就是Hi
Yeah. Hi.

292
00:13:29,371 --> 00:13:31,798
是H和I 因为如果你快速浏览到右边
H-I. Because if you skim ahead at the right there,

293
00:13:31,799 --> 00:13:37,219
刚好在ASCII里就是这么对应 72与H 73与I
that just happens to be in ASCII the mapping between 72 and 73, H and I.

294
00:13:37,220 --> 00:13:40,743
严格来讲 如果你愿意这条消息可有第三个字节
If technically, the message had a third byte, if you will.

295
00:13:40,744 --> 00:13:43,640
现在剧透一下你的好奇 一个字节就是八比特
A byte, if you've ever wondered, is just eight bits.

296
00:13:43,641 --> 00:13:45,829
用字节这个术语更方便一些 比起说八个比特
It's convenient to talk not in terms of single bits,

297
00:13:45,830 --> 00:13:48,960
尤其是在你不能计数太多的时候 而用字节即八比特
where you can't count very high, but with a byte, or eight bits,

298
00:13:48,966 --> 00:13:50,242
你可以计数更高
you can count higher.

299
00:13:50,243 --> 00:13:53,014
所以如果我接收到第三个字节
And so it turns out if I received a third byte,

300
00:13:53,015 --> 00:13:55,899
即另一个八位的0与1的组合序列
another sequence of eight zeros and ones together...

301
00:13:56,100 --> 00:13:56,789
假设它的十进制对应是33
33.

302
00:13:56,790 --> 00:13:59,200
我们该如何判断这条消息是什么
How would we know what this message now is?

303
00:14:00,280 --> 00:14:02,003
看上去最终貌似你不会知道这
Yeah. So it turns out you would not know this

304
00:14:02,010 --> 00:14:04,444
除非你大胆猜测或是谷歌一下又或者生来就知道这个知识点
other than by guessing or Googling or just coming in with this knowledge.

305
00:14:04,445 --> 00:14:05,859
现在这条消息是HI!
This is now "HI!"

306
00:14:05,860 --> 00:14:09,563
多了个感叹号是因为33就表示它 如果你查一查ASCII码表
with an exclamation point because 33 just so happens, if you look it up,

307
00:14:09,564 --> 00:14:12,579
也可以找到对应33的感叹号
to map to an exclamation point, as well.

308
00:14:12,580 --> 00:14:14,963
现在 如果我们真正以二进制来考查这个问题
Now, if we actually looked at the binary of this,

309
00:14:14,966 --> 00:14:17,179
你实际上会看到0与1的组合
you would actually see this pattern of zeros and ones.

310
00:14:17,180 --> 00:14:19,455
这里呈现的是如何用二进制表示72这个数
This is how you represent 72 in binary.

311
00:14:19,456 --> 00:14:21,200
这里是73的二进制表达
This is you represent 73.

312
00:14:21,203 --> 00:14:23,331
这是33的二进制形式
And this is how you represent 33.

313
00:14:23,332 --> 00:14:27,206
请注意我只用到了一二三四五六 六个比特位
And notice I've only used one, two, three, four, five, six bits,

314
00:14:27,310 --> 00:14:31,798
即使我实际上更想以八个比特来接收信息 即 以字节为单位
even though I technically tend to receive things in units of 8, units of bytes.

315
00:14:31,799 --> 00:14:37,106
那我又是为什么并没有去惊扰另外一两个零呢
But why did I not bother writing another 00 here and another 0 here?

316
00:14:38,309 --> 00:14:40,699
这会影响到当你想要写出这些东西吗
Does it matter when you write these things out?

317
00:14:41,410 --> 00:14:42,222
不 并不
No. Not really.

318
00:14:42,226 --> 00:14:46,542
就好比在我们人的思维里 比如英文 如果你打算写123
Like in English, in our human world, if you were to write one, two, three,

319
00:14:46,546 --> 00:14:47,832
那是一百二十三
that's 123.

320
00:14:47,833 --> 00:14:51,440
如果你写0123 那还是一百二十三
If you were to write 0, 1, 2, 3, that's still 123.

321
00:14:51,443 --> 00:14:54,190
所以即便我们试图每8个一簇地获取到那些数
So even though we tend to get them in clusters of 8,

322
00:14:54,191 --> 00:14:57,001
我们也不必在谈及于此的时候列出所有那些数位
we don't necessarily need to write those when just talking about them.

323
00:14:57,005 --> 00:14:58,043
所以我们成就了什么
So what have we done?

324
00:14:58,044 --> 00:15:00,529
好那么接下来让我来引入一个更炫酷的词它叫 抽象
Well, let me introduce a fancier word now known as abstraction.

325
00:15:00,530 --> 00:15:03,574
抽象 是一个在计算机科学领域被广泛使用的术语
Abstraction is just a term generally used in computer science

326
00:15:03,575 --> 00:15:06,673
并且之后很快我们会在编程方面对它有所了解 涉及到一些低级别的
and we'll soon see in programming for taking some low level

327
00:15:06,674 --> 00:15:11,185
实施细节 甚至譬如一些细枝末节
like literally low level implementation details, like minutiae even,

328
00:15:11,186 --> 00:15:12,817
以及会在某种情况下对这些有所理解
and understanding them at some point,

329
00:15:12,818 --> 00:15:16,179
但之后过于深究这个却不是一个从概念上来讲有效的维度
but then deciding this is not a useful level conceptually

330
00:15:16,180 --> 00:15:17,175
从而去思考问题
to think about problems.

331
00:15:17,176 --> 00:15:20,786
我真不太想在这个零一世界里去思考问题
I really don't want to solve problems in this world of thinking in 0's and 1's.

332
00:15:20,787 --> 00:15:24,409
我更愿意最低耗式地采用十进制思维 或者更好来讲
I'd much rather think about things minimally in decimal, or better yet,

333
00:15:24,410 --> 00:15:26,897
是放在字母的上下文中 如果我确实在接收文本
in the context of letters if I'm actually receiving text,

334
00:15:26,898 --> 00:15:28,659
或者一些其他呈现形式
or even some other representation.

335
00:15:28,660 --> 00:15:32,569
所以 抽象 就是把那些相当低级别的细节
So abstraction is about taking fairly low level details

336
00:15:32,570 --> 00:15:36,565
做简化 从而使我们可以有一个更有效的对话
and just simplifying them so that we can have a more useful conversation

337
00:15:36,566 --> 00:15:39,825
而且 再也不用担心电来自哪里
and never again worry about where the electricity is coming from.

338
00:15:39,826 --> 00:15:43,231
我们完全可以规范自己电脑是可以呈现那些0和1
We can just stipulate my computer can represent zeros and ones.

339
00:15:43,234 --> 00:15:44,701
因此 它可以表示数
Therefore, it can represent numbers.

340
00:15:44,702 --> 00:15:47,539
也可以表示ASCII或字母
Therefore, it can also represent ASCII or letters.

341
00:15:47,540 --> 00:15:51,106
于是我们稍微可以继续并开始解决更有趣的问题
And we can kind of move on and start solving more interesting problems.

342
00:15:51,412 --> 00:15:57,901
但似乎我们并不能解决所有的问题 因为在我这个键盘上
But it would seem that we can't solve all problems because on my keyboard here,

343
00:15:57,902 --> 00:16:00,844
这个美式键盘 有一大堆字母字符这些
this American keyboard here, there's a whole bunch of symbols,

344
00:16:00,845 --> 00:16:02,715
整个差不多有个一两百
like a 100 or 200 maybe in total

345
00:16:02,716 --> 00:16:05,104
当我们实际会敲shift键option键以及所有那些
if we actually hit shift and option and all of that.

346
00:16:05,105 --> 00:16:07,905
但你所没看到的是一些特别常用的字符
But what you don't see are some pretty common characters.

347
00:16:07,906 --> 00:16:09,575
尤其是在一个非常国际化的受众之中
Especially in a very international audience,

348
00:16:09,576 --> 00:16:12,194
是什么字符我甚至都不能从键盘上敲
what can I apparently not even type on this keyboard?

349
00:16:13,099 --> 00:16:14,706
哪种符号
What kinds of symbols? Yeah.

350
00:16:15,500 --> 00:16:16,802
带有重音符号的对吧
Anything with an accent.

351
00:16:16,803 --> 00:16:18,802
如果你遇到元音字母上面有重音符号或者其他类型字母
If you have accents over vowels or other letters.

352
00:16:18,803 --> 00:16:19,603
还有其他吗
What else?

353
00:16:20,253 --> 00:16:21,005
不好意思没太清听
I'm sorry.

354
00:16:21,433 --> 00:16:23,798
曲音符号或者其他在字母之上出现的字符 正确
Umlauts or other characters above letters. Yeah.

355
00:16:24,309 --> 00:16:26,789
又比如英镑符号
Like pound symbol?

356
00:16:26,790 --> 00:16:28,399
对 英国的英镑符号
Like the UK pound symbol.

357
00:16:28,400 --> 00:16:29,859
正确 其他国家也同理
Sure. And other countries, too.

358
00:16:29,860 --> 00:16:31,331
还比如好些个亚洲语言
Any number of Asian languages.

359
00:16:31,332 --> 00:16:33,596
有很多符号没有在这个键盘上被标识出来
There's so many symbols that are not depicted on this keyboard,

360
00:16:33,597 --> 00:16:37,176
但总之 我们所有人都使用国际化的手机或键盘
and yet somehow, all of us with international keyboards or phones

361
00:16:37,177 --> 00:16:38,885
这些设备工具的功能很清晰
can surely express themselves.

362
00:16:38,886 --> 00:16:42,701
但那是因为如今的手机和电脑不只是使用ASCII码
But that's because phones and computers these days don't just use ASCII.

363
00:16:42,702 --> 00:16:45,571
ASCII码确实一共只使用了8比特
ASCII literally used just eight bits total.

364
00:16:45,572 --> 00:16:48,089
实际上7个但最终真的是8个
Technically seven, but then, ultimately, really eight.

365
00:16:48,090 --> 00:16:49,933
于是拥有这8个比特 如果你老老实实做个数学
And with eight bits, if you actually do the math...

366
00:16:49,934 --> 00:16:52,177
打比方你有8个比特或者说8根手指吧
if you have eight bits or eight fingers,

367
00:16:52,178 --> 00:16:56,451
你只能有总共256种可能的方式排列它们
you can only permute them in 256 total possible ways,

368
00:16:56,452 --> 00:17:01,000
也就是说你用ASCII码只能呈现256个不同字符
which is to say that you can only represent 256 characters using ASCII

369
00:17:01,001 --> 00:17:03,032
这就是机制背后的数目
with numbers underneath the hood,

370
00:17:03,033 --> 00:17:07,149
而那是不足以代表这么多不同符号的 比如刚枚举的那些
and that's not enough to represent so many different symbols like those enumerated here.

371
00:17:07,150 --> 00:17:08,686
你不能表示任何重音符号
You can't represent any of the accents

372
00:17:08,687 --> 00:17:10,921
那些你却可以在Mac或PC上敲击出来的符号
that you can nonetheless type on your Macs and PCs

373
00:17:10,925 --> 00:17:14,284
并且显然你也不能打字出这些东西 它们最近很火
and you certainly can't type these things, which are very much in vogue.

374
00:17:14,285 --> 00:17:18,094
尽管看似图片但它们实际只是些字符
Which even though they're pictures, they're actually just characters.

375
00:17:18,095 --> 00:17:19,892
说来是好几年前
Because it turns out some years ago,

376
00:17:19,893 --> 00:17:22,532
8个比特显然是不够了
the world decided eight bits is not enough.

377
00:17:22,535 --> 00:17:24,681
我们开始使用一种叫Unicode的东西
Let's start using something called Unicode,

378
00:17:24,685 --> 00:17:28,764
那样你实际可以用1个2个3个甚至或是4个字节
where you actually use one or two or three or even four bytes.

379
00:17:28,765 --> 00:17:33,993
换算一下也分别是8比特 16比特 24比特 甚至32比特来表示字符
So eight bits or 16 bits, 24 bits, or even 32 bits to represent characters.

380
00:17:33,994 --> 00:17:37,950
因此现在 我们能够表示上千甚至上百万多个字符
And now, we have the ability to represent thousands or even millions of characters.

381
00:17:37,951 --> 00:17:43,230
而且坦白讲 我敢说 那样巨大数量的可用空间所带来的结果
And frankly, daresay, the result of that huge amount of availability

382
00:17:43,231 --> 00:17:45,775
就是可以说为什么现如今有这么多这些事物
is partly why there are so many of these things these days.

383
00:17:45,776 --> 00:17:46,835
而且还在不断增多
And they just keep making more

384
00:17:46,836 --> 00:17:49,700
因为正好有这么多不同的数供我们使用
because there's just so many different numbers available to us.

385
00:17:49,704 --> 00:17:53,619
所以Unicode就是... 通常它的一个特别版叫UTF-8
So Unicode is often a specific version of it called UTF-8,

386
00:17:53,620 --> 00:17:54,750
我们不久之后将会学到
which we'll see before long.

387
00:17:54,751 --> 00:17:56,587
但我在这儿得问这么一个问题
But let me ask this question here.

388
00:17:56,588 --> 00:18:02,239
这是一个笑哭的表情 我猜是这么叫哈
This is a crying face with joy, I think this is called.

389
00:18:02,240 --> 00:18:04,399
那么根据苹果及其iOS 它就是...
So it turns out, according to Apple or iOS,

390
00:18:04,400 --> 00:18:06,979
这是最火的一个emoji 至少果粉们
this is the most popular emoji that at least iPhone people

391
00:18:06,980 --> 00:18:08,259
互相发送
are sending to each other.

392
00:18:08,260 --> 00:18:10,067
当你收到这个表情
So when you're receiving this, though,

393
00:18:10,068 --> 00:18:11,902
如果我们真的为此逗乐一番
if we can really take the fun out of this,

394
00:18:11,906 --> 00:18:15,390
你从朋友那里接收到的是什么形式的比特位
what pattern of bits are you actually receiving from your friend?

395
00:18:15,391 --> 00:18:18,093
他或她明显试图表达某种情绪
He or she is clearly trying to express some emotion,

396
00:18:18,094 --> 00:18:24,590
但是讲真 你的朋友发送给你的 竟是这个十进制数 128514
but really, what your friend is sending you... the decimal number 128,514.

397
00:18:24,591 --> 00:18:27,214
如果你看看那些0和1
Or really, if you looked at the zeros and ones coming

398
00:18:27,215 --> 00:18:29,539
通过互联网或者无线电波传达至你
to you over the internet or airwaves,

399
00:18:29,540 --> 00:18:31,547
那么你就是在接收那些0和1的组合形式
you're getting this pattern of zeros and ones,

400
00:18:31,548 --> 00:18:34,979
那不是可以很好描述
which is hardly joyful or hardly descriptive,

401
00:18:34,980 --> 00:18:38,569
但你的手机或电脑所做的一切就是看见了这种比特位的组合
but all your phone or computer are doing is seeing this pattern of bits,

402
00:18:38,570 --> 00:18:41,059
把它们整理到一个小的整洁的表单里来查看 然后猛然发现
looking it up in like a little cheat sheet, and saying, oh.

403
00:18:41,060 --> 00:18:44,734
每当我在短信文本的上下文里看见这种比特位的形式
Whenever I see this pattern of bits in the context of text like texting,

404
00:18:44,735 --> 00:18:47,606
我就应该以那个图片的形式呈现它
I should actually display it as that picture.

405
00:18:47,993 --> 00:18:51,665
现在来看那个图片里有很多黄色以及其他颜色在里面
Now, that picture has a lot of yellow and other colors in it,

406
00:18:51,666 --> 00:18:53,480
我们是如何做到的呢
but how do we even get there?

407
00:18:53,481 --> 00:18:56,051
嗯 那就是相关于之前那种数目形式
Well, it turns out that this same pattern of numbers...

408
00:18:56,052 --> 00:19:00,400
72 73 33 之前讲过 代表什么
72, 73, 33... which just to be sure, a moment ago, meant what?

409
00:19:00,730 --> 00:19:01,130
那就是 Hi
Hi.

410
00:19:01,131 --> 00:19:05,186
在文本处理程序的环境中 比如微软word Goggle Docs 以及短信
In the context of a textual program like Microsoft Word, Google Docs, texting,

411
00:19:05,187 --> 00:19:06,514
这个意思是Hi
this means hi.

412
00:19:06,515 --> 00:19:10,409
但假如你看到字节也以这种方式呈现会怎样
But what if you saw this same pattern of bytes...

413
00:19:10,410 --> 00:19:12,412
再者 我们可以画出0和1
and again, we could draw the zeros and ones,

414
00:19:12,413 --> 00:19:13,862
可这样就根本无意义了
but it's not interesting anymore,

415
00:19:13,863 --> 00:19:16,064
所以我们准备在十进制体系中也做抽象
so we're going to abstract away at the decimal level.

416
00:19:16,065 --> 00:19:17,794
如果你得到这种形式排列的0和1
If you got this same pattern of zeros and ones

417
00:19:17,795 --> 00:19:21,656
或者在诸如Photoshop或浏览器环境中的数
or numbers in the context of like Photoshop or a browser

418
00:19:21,657 --> 00:19:23,599
或者在照片程序里
or some kind of photo program,

419
00:19:23,600 --> 00:19:26,904
那么解释它会更有意义 不是作为文本
well, it might make more sense to interpret it not as text,

420
00:19:26,905 --> 00:19:29,435
而是作为图像 有些颜色
but as imagery, some kind of colors.

421
00:19:29,436 --> 00:19:31,651
那么很好 这最终带来了世上的另一个体系
Well, it turns out there's this other system in the world...

422
00:19:31,652 --> 00:19:33,179
你们兴许曾经见过这个首字母缩略词
you might have seen this acronym before...

423
00:19:33,180 --> 00:19:35,989
它叫RGB... 意思是红绿蓝
called RGB... red, green, blue.

424
00:19:35,990 --> 00:19:39,439
这就是人们所已经标准化了的
And this is just a way of humans having standardized

425
00:19:39,440 --> 00:19:40,482
你们知道吗几年前
years ago that you know what?

426
00:19:40,483 --> 00:19:42,962
如果我们想在某人的屏幕上呈现一个点
If we want to represent a dot on someone's screen,

427
00:19:42,963 --> 00:19:45,484
同理称之为一个像素 即屏幕上的一个非常小的方形
otherwise known as a pixel a tiny little square on the screen

428
00:19:45,485 --> 00:19:48,364
无论是手机屏 笔记本电脑屏 甚至如今的电视机屏
of your phone, your laptop, or even TV these days,

429
00:19:48,365 --> 00:19:50,482
我们准备用这三个字节
we're going to use three bytes...

430
00:19:50,483 --> 00:19:54,430
其中一个字节用来体现某一个像素里该有多少红色
one byte to specify how much red should be in that specific pixel,

431
00:19:54,431 --> 00:19:58,102
再来一个字节则表示红色里该掺入多少绿色
one more byte to specify how much green should be combined with red

432
00:19:58,103 --> 00:20:00,240
为了构成那个像素 需要再多一个字节
to form that pixel, and then one more byte,

433
00:20:00,243 --> 00:20:04,144
第三个字节 说明该往之前两种颜色里加入多少蓝色
a third, to represent how much blue to combine with those other two colors

434
00:20:04,145 --> 00:20:06,160
从而三者一起形成一个新颜色
to make a new color all together.

435
00:20:06,163 --> 00:20:09,673
这有点调颜色的感觉 但注意有种情况
So it's kind of like combining paints, except in this case,

436
00:20:09,676 --> 00:20:13,755
用光波来获得某个特定颜色
it's more really waves of light in order to get a specific color

437
00:20:13,756 --> 00:20:17,014
用红绿蓝作为你的调色盘
using just red, green, and blue as your palette.

438
00:20:17,015 --> 00:20:20,941
就这三种颜色而言来说
And so if we were to see this red, green, blue pattern and say,

439
00:20:20,942 --> 00:20:21,353
你猜怎样
you know what?

440
00:20:21,354 --> 00:20:26,270
给我72这么多红色 73这么多绿色 33这么点蓝色
Give me 72 red, 73 of green, and 33 of blue.

441
00:20:26,271 --> 00:20:31,022
如果总的可能的范围是正如我之前稍微提及到的从0到256
If the total possible range that I alluded to earlier is like 0 to 256,

442
00:20:31,026 --> 00:20:36,296
或者严格来说是0到255 如果按在计算机科学里的习惯从0开始计数
or technically 0 to 255 if you start counting in computer science from zero,

443
00:20:36,297 --> 00:20:39,353
这好像是含有中等数量的红色 中等数量的绿色
this is like a medium amount of red, medium amount of green,

444
00:20:39,356 --> 00:20:42,584
和一点点蓝色 如果范围从0到255来衡量
and just a little bit of blue, if the range goes from 0 to 255.

445
00:20:42,585 --> 00:20:44,649
接着如果你把这三样结合在一起
So if you combine these three things together

446
00:20:44,650 --> 00:20:46,504
你想知道能得到什么颜色
and you want to know what color you get...

447
00:20:48,000 --> 00:20:51,247
那么会是看上去这个样子的一种淡黄色
Yeah. So it's kind of a light yellow that looks like this.

448
00:20:51,248 --> 00:20:54,795
所以 如果电脑储存屏幕上的一个点
So if a computer is storing a single dot on the screen

449
00:20:54,796 --> 00:20:56,523
怎么让它是黄色
that happens to be in yellow,

450
00:20:56,524 --> 00:20:58,252
电脑实际上真正存储的是什么
what the computer's actually storing

451
00:20:58,253 --> 00:21:01,759
这不是一个实实在在的点 而是三个字节的一种组合形式
is not this dot physically, but a pattern of three bytes

452
00:21:01,760 --> 00:21:03,609
配有多少红色多少绿色多少蓝色
...how much red, how much green, how much blue

453
00:21:03,610 --> 00:21:06,033
一起呈现在电脑上这个特定点的位置
should the computer display at this particular point.

454
00:21:06,034 --> 00:21:09,014
所以 如果我们看着这个笑哭的脸
So if we look at this crying face of joy
那么我们再回到这个笑哭的表情
So if we look at this crying face of joy

455
00:21:09,015 --> 00:21:11,856
如果把它放大
and we kind of enhance or zoom in on it here,

456
00:21:11,865 --> 00:21:14,910
你就会发现它开始像素化
you can actually see it start to pixelate, so to speak,

457
00:21:14,911 --> 00:21:16,290
意思就是你能看清那些像素点了
where you start to see the dots.

458
00:21:16,291 --> 00:21:17,533
如果我再拉近一些
If I punch in a little more,

459
00:21:17,534 --> 00:21:20,600
屏幕上显示的像素点就更明显了
now you can really start to see the dots on the screen.

460
00:21:20,601 --> 00:21:23,404
如果我继续拉近 最终你能看到的
And if I go an even further, you can actually see

461
00:21:23,405 --> 00:21:25,835
就是组成这个表情的像素小方块
the tiny little squares that compose this image,

462
00:21:25,836 --> 00:21:28,395
在这个范围中 大部分像素点都是黄色的
most of which at the zoom level are yellow,

463
00:21:28,396 --> 00:21:29,979
有小部分是黑色
but a bunch of which are black,

464
00:21:29,980 --> 00:21:33,731
还有一部分是浅黑色或者深黄色
a bunch of which are light black or dark yellow.

465
00:21:33,732 --> 00:21:36,353
它们共同组成了这个表情
And that's what composes this image ultimately.

466
00:21:36,354 --> 00:21:40,502
换句话说 如果把屏幕上的这些像素点都加起来
So this is to say if you count up all of the pixels on the screen

467
00:21:40,503 --> 00:21:43,565
再乘以一 二 三个单位的字节
and then multiply it by one, two, three bytes,

468
00:21:43,566 --> 00:21:47,463
或者所谓的字节 千字节与兆字节 在座可能有人听过这几个词
that's how many bytes or kilobytes or megabytes, if you've heard those terms,

469
00:21:47,464 --> 00:21:51,697
就是你的电脑显示一张图片所需的字节量
are going to be stored on your computer just to represent an image.

470
00:21:52,118 --> 00:21:56,732
我们从最初的电流 讲到零和一
So we've gone from electricity to down here, so to speak, to zeros and ones,

471
00:21:56,733 --> 00:21:58,574
再到十进制 刚刚又讲完了色彩
to decimal, now to colors.

472
00:21:58,575 --> 00:22:00,803
有色彩 才有图片
Well, with colors, you can get images.

473
00:22:00,804 --> 00:22:02,113
那么有图片又有什么呢
What comes after images?

474
00:22:02,114 --> 00:22:05,774
我们现在经常会看一些视频或者电影
Well, we've all watched videos or movies certainly digitally these days.

475
00:22:05,775 --> 00:22:08,000
视频和电影文件是什么
Well, what is a movie or a video file?

476
00:22:08,003 --> 00:22:09,700
它们是怎么产生的
How might that be implemented?

477
00:22:12,132 --> 00:22:13,499
再大声一些
Say it a little louder.

478
00:22:14,184 --> 00:22:15,550
对 它们实际上就是图片的集合
Yeah. It's a collection of images.

479
00:22:15,551 --> 00:22:17,101
人们常说的帧率 也就是每秒帧数
If you've ever heard of frames per second...

480
00:22:17,102 --> 00:22:21,264
比如有的电影是每秒24帧 有的是每秒30帧
like movies tend to be 24 frames per second or 30 frames per second...

481
00:22:21,265 --> 00:22:23,304
意思是 一部电影
that just means that a typical movie,

482
00:22:23,305 --> 00:22:27,352
每秒向你展示24张或30张图片
every second is showing you 24 or 30 images per second

483
00:22:27,353 --> 00:22:29,339
它们出现的速度之快
and they're just flying by so quickly

484
00:22:29,340 --> 00:22:32,489
甚至让你意识不到自己是在看一组静态的图片
that you actually don't notice you're just watching a sequence of static images.

485
00:22:32,490 --> 00:22:35,369
就像小时候大家玩过的那种动画书
It's like as a kid, if you ever had one of those paper flip books

486
00:22:35,370 --> 00:22:37,042
一本书就是一叠图画
where there's tons of drawings in them,

487
00:22:37,043 --> 00:22:38,669
随着你迅速地翻动书页
and as you flip through the pages,

488
00:22:38,670 --> 00:22:40,695
图画就会动起来
you see things moving, but that's just because（或许英文前半句可以并入上一行，后半句可以并入下一行？）

489
00:22:40,696 --> 00:22:43,507
其原理就在于 你的眼睛在短时间内接收了这些图片信息
your eyes are just seeing little snapshots ever so quickly

490
00:22:43,508 --> 00:22:45,811
将其处理成了动态画面
of something moving on the paper.

491
00:22:45,812 --> 00:22:47,793
这就是视频的本质
That's all a video file actually is.

492
00:22:47,794 --> 00:22:50,480
如果你用的是iPhone 之前有玩过这些动画表情的话
So if you have an iPhone and you've ever played with these animojis,

493
00:22:50,483 --> 00:22:53,774
它们实际上就是一些小的视频文件
so to speak, well, all those are, are little video files

494
00:22:53,775 --> 00:22:56,294
由很多很多张图片组成
composed of lots and lots and lots of images

495
00:22:56,295 --> 00:23:00,402
它们被存在你的手机里 或者被你用短信发给别人
that you have saved on your phone or texted to someone else.

496
00:23:00,403 --> 00:23:03,760
所以现在想想 虽然讲到了视频这一级 但也没什么复杂的
And if we just think, now, we're at the point of video, but that's OK.

497
00:23:03,763 --> 00:23:05,227
视频就只是图片的集合
Videos are just bunches of images.

498
00:23:05,228 --> 00:23:06,906
图片只是色彩的集合
Images are just bunches of colors.

499
00:23:06,907 --> 00:23:09,299
色彩也只不过是数位排列的方式
Colors are just patterns of bits.

500
00:23:09,300 --> 00:23:09,982
而数位 说到底
And bits, at the end of the day,

501
00:23:09,986 --> 00:23:12,684
就只是机器中电流作用的结果
are just the result of electricity coming into my machine

502
00:23:12,685 --> 00:23:15,115
只是晶体管不停开关的结果而已
or transistors turning switches on and off.

503
00:23:15,116 --> 00:23:18,141
虽然我们刚才把所有的层级都梳理了一遍
Like we've all of a sudden to hold this entire story,

504
00:23:18,142 --> 00:23:22,272
但大家看视频时并不会想到什么二进制
but none of us ever is going to need to really think about binary in the context of videos

505
00:23:22,273 --> 00:23:25,925
因为视频是基于图片的抽象
because a video is just an abstraction on top of bunches of images,

506
00:23:25,926 --> 00:23:29,883
图片又是基于像素点的抽象 以此类推
and images are just an abstraction on top bunches of pixels, and so forth.

507
00:23:29,884 --> 00:23:32,002
根据这个层级顺序
So we can keep painting this hierarchy

508
00:23:32,003 --> 00:23:34,469
我们就能以更有效的方式来讨论问题了
that just allows us to talk about things at a more useful level,

509
00:23:34,470 --> 00:23:36,332
之所以介绍这些
and the reason we had this conversation

510
00:23:36,333 --> 00:23:38,977
是因为我们要用一种方式
is just because we needed a way to represent

511
00:23:38,978 --> 00:23:41,603
把输入输出 和问题联系起来
inputs and outputs to problems.

512
00:23:41,885 --> 00:23:45,693
到目前为止 大家有没有什么问题
Let me pause there for just a second to see if there's any questions.

513
00:23:46,928 --> 00:23:48,107
有什么想问的
Anything at all?

514
00:23:49,429 --> 00:23:50,180
没有吗
No?

515
00:23:50,180 --> 00:23:50,539
好吧
All right.

516
00:23:50,540 --> 00:23:53,004
那么 这个黑匣子里到底是什么呢
So what's inside this black box?

517
00:23:53,005 --> 00:23:56,381
这个部分 就是那些有趣的创意开始的地方
Well, it turns out this is where the really interesting work

518
00:23:56,382 --> 00:23:58,577
人类思考介入的起点
starts to happen and the thought starts to come in.

519
00:23:58,578 --> 00:24:02,339
这就是所谓的算法 即一步一步按步骤
This is the proverbial algorithms, step by step instructions

520
00:24:02,340 --> 00:24:03,800
解决问题的方式
for solving some problem.

521
00:24:03,801 --> 00:24:05,956
下面这种情况 大家以前可能也遇到过
And some of you might have solved this problem before,

522
00:24:05,957 --> 00:24:07,993
无论是电子版还是纸质版
either digitally or textually, but of course,

523
00:24:07,996 --> 00:24:10,572
大家的手机里都有联系人吧
if you have contacts in your phone these days

524
00:24:10,573 --> 00:24:12,242
各种朋友和亲人的联系方式
and you've got bunches of friends and family,

525
00:24:12,243 --> 00:24:14,952
基本都按姓或名的字母顺序排列
odds are they're alphabetized by first name or last name.

526
00:24:14,953 --> 00:24:17,779
现在手机都自动排序了 实际上还是一个列表
And you have auto complete these days, but it really is just a long list

527
00:24:17,780 --> 00:24:18,948
记着人名和号码
of names and numbers.

528
00:24:18,949 --> 00:24:21,513
跟以前的办法也没什么不同
That's not all that different from yesteryear's implementation

529
00:24:21,516 --> 00:24:25,155
就是我现在手里拿的这个 一本电话簿
of the same problem, which was this device here, a phonebook.

530
00:24:25,156 --> 00:24:27,915
假设我们在这本电话簿里有个朋友
Now, this phonebook might have a friend of ours in it, say

531
00:24:27,916 --> 00:24:30,179
叫迈克·史密斯 他的姓首字母是S
Mike Smith, whose last name starts with S.

532
00:24:30,180 --> 00:24:32,518
如果我想找到迈克的联系方式
And I could, of course, if trying to find Mike Smith,

533
00:24:32,519 --> 00:24:34,739
从第1页开始找起
start by looking at the first page,

534
00:24:34,740 --> 00:24:38,301
然后是第2 第3 第4页
the second page, the third page, the fourth page,

535
00:24:38,302 --> 00:24:40,329
最终总能找到迈克
and eventually, just hopefully find Mike Smith.

536
00:24:40,330 --> 00:24:43,202
那么这种算法 这种按步进行的方式
Indeed, is this algorithm, this step by step process,

537
00:24:43,203 --> 00:24:46,006
能找到迈克吗
correct for finding someone like Mike Smith?

538
00:24:46,460 --> 00:24:47,380
没错 它是可行的
Yeah. It's correct.

539
00:24:47,381 --> 00:24:49,289
虽然笨了些 慢了些
It's stupid and slow perhaps

540
00:24:49,290 --> 00:24:52,006
这么厚的一本 估计到猴年马月都找不完
because it's going to take forever in a phone book of this size,

541
00:24:52,007 --> 00:24:55,159
但确实是可行的 只要迈克的名字在里面 最终总能找到
but it is correct because if Mike's in here, I will, in fact, find him.

542
00:24:55,160 --> 00:24:56,185
我也可以换一个更好的办法
But I could do this better.

543
00:24:56,186 --> 00:24:57,638
一次翻两页
I could do it sort of two at a time.

544
00:24:57,639 --> 00:25:01,491
2 4 6 8 10
So two, four, six, eight, 10... or imperfectly...

545
00:25:01,492 --> 00:25:04,493
10 12 14 是不是快一些
10, 12, 14. Is that faster?

546
00:25:04,758 --> 00:25:08,295
很显然 快了一倍 那它是正确的吗
Obviously, it's going twice as fast. Is it correct?

547
00:25:09,342 --> 00:25:10,806
不正确 为什么呢
No. Why is it not correct?

548
00:25:11,596 --> 00:25:12,820
因为我可能会错过他 对吧
Yeah. I might miss him, right?

549
00:25:12,824 --> 00:25:16,142
迈克很可能恰好位于两页之间
Mike just accidentally might eventually get sandwiched between two pages

550
00:25:16,146 --> 00:25:18,893
而我却不巧错过了
and I have the unlucky experience of just missing him.

551
00:25:18,897 --> 00:25:20,569
那可以补救吗 当然
Now, is it fixable? Yeah.

552
00:25:20,570 --> 00:25:24,960
比如我翻到SN或者T开头的部分时
I can probably, once I hit like SN or the T section, for instance...

553
00:25:24,963 --> 00:25:27,209
发现已经错过迈克了
I can just say, obviously, I've gone too far for Mike.

554
00:25:27,210 --> 00:25:29,424
就再往回翻一页或者几页
Let me just double back one or just a few pages.

555
00:25:29,425 --> 00:25:30,445
这是可以补救的
So it is fixable.

556
00:25:30,446 --> 00:25:33,906
更何况我前面这样翻 能省一半的时间
And so long as I've saved time by flying through this twice as fast,

557
00:25:33,907 --> 00:25:37,713
最后我再多费几步 倒回来找迈克
can I at least afford to spend a few more steps at the very end

558
00:25:37,714 --> 00:25:39,282
又有何不可呢
just to find Mike Smith?

559
00:25:39,283 --> 00:25:40,563
但没有人会这么做的
But none of us are going to do that.

560
00:25:40,564 --> 00:25:42,642
出于效率 我们的苹果和安卓设备
And our Apple devices and Android devices

561
00:25:42,643 --> 00:25:44,851
并不会采用这种方法
certainly don't do that for efficiency today.

562
00:25:44,852 --> 00:25:48,310
要在这么厚的一本书里找到某个人 大部分人会怎么做呢
Odds are most of us are going to do what to find someone in any book like this?

563
00:25:49,043 --> 00:25:49,346
没错
Yeah.

564
00:25:49,347 --> 00:25:50,781
把书大概对半分
Open to roughly the middle

565
00:25:50,782 --> 00:25:52,319
或偏后半部分
or maybe bias ourselves toward the end

566
00:25:52,320 --> 00:25:53,723
毕竟字母S在中间靠后的位置
because S is after the middle.

567
00:25:53,724 --> 00:25:55,842
总之 我现在翻到了这本电话簿的中间
But you know, I'm in the middle of the phonebook here.

568
00:25:55,843 --> 00:25:59,310
已知迈克的姓氏以S开头 因此他在这后半部分
And now, if I know that Mike is in the S's and therefore over here,

569
00:25:59,311 --> 00:26:01,099
那么哪一边没有他呢
where do I know he's not?

570
00:26:01,766 --> 00:26:03,693
是前半部分 所以我可以直接把问题
He's not in the beginning and I can literally

571
00:26:03,694 --> 00:26:08,009
像这样一分为二 直接丢掉无关的这半部分
tear a problem like this in half, throw figuratively and literally

572
00:26:08,010 --> 00:26:12,061
从字面和引申义来看 丢掉一半之后从头再来
half of the problem away, and be left with fundamentally the same problem,

573
00:26:12,062 --> 00:26:12,985
就只剩一半了
but it's half as big.

574
00:26:12,986 --> 00:26:13,916
就假设...
I went from like... whatever...

575
00:26:13,917 --> 00:26:15,969
从1000页减到了500页
1,000 pages to 500 pages

576
00:26:15,970 --> 00:26:17,790
再重复之前的算法步骤
and I can now repeat this algorithm.

577
00:26:17,791 --> 00:26:18,651
打开书
I look down.

578
00:26:18,652 --> 00:26:19,537
发现翻过头了
I'm a little too far.

579
00:26:19,538 --> 00:26:20,979
已经到T的部分了
I'm in the T section now.

580
00:26:20,980 --> 00:26:21,513
好
OK.

581
00:26:21,514 --> 00:26:25,542
那么我就再把问题一分为二 扔掉另一半
I can again tear the problem in half, throw that half away,

582
00:26:25,543 --> 00:26:28,511
刚才扔了500页字节 现在再扔250页字节
taking a 500 page byte out, a 250 page byte out,

583
00:26:29,230 --> 00:26:31,581
我手里就只剩下250页了
now leaving myself with just 250 pages more.

584
00:26:31,582 --> 00:26:33,245
注意到这个速度变化了吗
And notice just how quickly I got here.

585
00:26:33,246 --> 00:26:37,731
前两种算法是从1000到999 再到998
The first two algorithms got me from 1,000 to 999 to 998,

586
00:26:37,732 --> 00:26:41,439
或者从1000到998 再到996
or 1,000 to 998 to 996.

587
00:26:41,440 --> 00:26:44,292
但用这种算法 一下就从1000变成500 再变成250
But here, I went from 1,000 to 500 to 250.

588
00:26:44,295 --> 00:26:46,239
是不是省了很多时间
Feels like we're making up time here.

589
00:26:46,240 --> 00:26:48,118
如果这个步骤一直重复下去
And indeed, if I keep repeating this process,

590
00:26:48,119 --> 00:26:50,955
最终我只会剩下一张纸
hopefully, I'll be left with just one page of the book

591
00:26:50,956 --> 00:26:55,502
迈克的名字不是在正面就是在背面 找到之后 我就可以打给他了
that Mike is either on or not, at which point, I will call him.

592
00:26:55,620 --> 00:27:00,040
所以算法 就是大家充分利用自己的直觉
And so that's an algorithm that honestly leverages probably all the intuition we have

593
00:27:00,041 --> 00:27:01,731
以及未来要讲到的各种编程知识
and a lot of what programming is going to be,

594
00:27:01,732 --> 00:27:03,475
用刚才讲的算法逻辑去思考问题
is thinking about a problem like this,

595
00:27:03,476 --> 00:27:05,589
该如何切割划分 如何解决
figuring out how to divide and conquer it,

596
00:27:05,590 --> 00:27:07,076
再用电脑能理解的语言
and then expressing yourself in a way

597
00:27:07,077 --> 00:27:09,439
把你的想法表达出来 让它替你去解决问题
that the computer can then solve that problem for you.

598
00:27:09,440 --> 00:27:13,101
如果用图来解释最后的算法到底好在哪里的话
And just to paint a picture of how much better this algorithm is,

599
00:27:13,102 --> 00:27:16,256
在这个抽象坐标系里 纵轴
well, if this is just a very abstract chart where we have on the vertical,

600
00:27:16,265 --> 00:27:19,071
或者说y轴 代表解决问题的时长
or y-axis, how much time it takes to solve a problem,

601
00:27:19,072 --> 00:27:21,816
横轴代表问题的量级
and on the horizontal axis how big the problem is...

602
00:27:21,817 --> 00:27:24,983
越往右意味着这个问题的量级越大
so the farther out you go this way, the more pages in the problem,

603
00:27:24,984 --> 00:27:26,217
电话簿的页数更多
the more pages in the phonebook.

604
00:27:26,218 --> 00:27:28,169
而越往上意味着时长越长
And the higher you go up here, the more seconds

605
00:27:28,170 --> 00:27:29,800
要翻页的次数越多
or page turns it's going to take.

606
00:27:29,801 --> 00:27:33,283
第一种算法就像一条斜线
That first algorithm is just like a linear slope,

607
00:27:33,284 --> 00:27:36,200
因为书本每增加一页
so to speak, because for every additional page in the book,

608
00:27:36,201 --> 00:27:37,748
我就要多花一秒钟
it might take me one more second.

609
00:27:37,749 --> 00:27:39,205
右 上 右 上
Right, up.

610
00:27:39,206 --> 00:27:42,136
页数和时长的增长量是一一对应的
It's just a one for one relationship with pages.

611
00:27:42,137 --> 00:27:44,359
第二种算法 如果要画出来的话
The second algorithm, if I plot it,

612
00:27:44,360 --> 00:27:45,871
翻页的速度翻倍
where I'm flying through twice as fast,

613
00:27:45,874 --> 00:27:48,100
它的曲线应该是什么样子的
what is that line going to look like instead?

614
00:27:52,020 --> 00:27:54,291
对 它会比上一条稍低一些
Yeah. It's going to look lower than this one.

615
00:27:54,292 --> 00:27:55,944
它还是一条直线
It's still going to be a straight line because now,

616
00:27:55,945 --> 00:27:57,654
但变成了1比2的关系
there's a two to one relationship,

617
00:27:57,665 --> 00:28:00,114
假设你的电话簿有这么多页
but if you've got a phone book that's got this many pages,

618
00:28:00,115 --> 00:28:03,445
用第一种算法 你要翻这么多次 到这
and in the first algorithm, it took this long, here,

619
00:28:03,446 --> 00:28:07,289
而第二种算法 次数就减半了
well, in the second algorithm, it will take half as many steps,

620
00:28:07,290 --> 00:28:10,381
算上调整的话也就是一半左右 稍有出入
plus or minus or two if you need to actually double back a little bit.

621
00:28:10,382 --> 00:28:13,176
第三种算法 就是我们常说的对数曲线
But that third algorithm is what we'll call logarithmic.

622
00:28:13,177 --> 00:28:15,619
假设电话簿的页数为n页
If n is the number of pages in the phone book,

623
00:28:15,620 --> 00:28:17,442
最耗时的第一种算法
the first algorithm, in the very worst case,

624
00:28:17,443 --> 00:28:19,661
可能要翻完n页才能找到迈克·史密斯
might take all n pages to find Mike Smith.

625
00:28:19,662 --> 00:28:21,769
第二种算法也得花一半的时间
The second algorithm is going to take half as many steps

626
00:28:21,770 --> 00:28:23,501
因为翻页速度翻倍了
because I'm flying through it two at a time.

627
00:28:23,502 --> 00:28:26,792
而第三种算法的曲线会是这样的
But the third algorithm is going to look and feel like this.

628
00:28:26,793 --> 00:28:31,160
它是一条增长速度越来越慢的曲线
It's going to be curved and ever so slowly rising and rising and rising,

629
00:28:31,161 --> 00:28:34,459
也就是说 假设威讯或者别的电话运营商
the implication of which is if Verizon or the phone company

630
00:28:34,460 --> 00:28:36,813
下一年要把电话簿的页码数翻倍
doubles the number of pages in the phonebook next year

631
00:28:36,814 --> 00:28:40,029
因为坎布里奇市和萨默维尔市[均为美国马萨诸塞州城市]要合用一本电话簿了
because Cambridge and Somerville merged together in the phone book

632
00:28:40,030 --> 00:28:41,736
现在它变成了2000页
and we now have 2,000 pages.

633
00:28:41,737 --> 00:28:45,102
如果用第三种算法来解决的话要用几步呢
Well, how many more steps does my third algorithm take?

634
00:28:45,718 --> 00:28:46,302
一步
Just one.

635
00:28:46,303 --> 00:28:48,866
因为我可以一次性就解决掉其中1000页
Because I can take a 1,000 page bite out of the problem

636
00:28:48,867 --> 00:28:52,275
而前两种算法
with that clever algorithm, whereas my first two algorithms（或许前半句可以并到上一行）

637
00:28:52,276 --> 00:28:54,701
却还是只能一页或两页地翻
would take it one or just two pages at a time.

638
00:28:54,702 --> 00:28:59,264
有了这个算法 问题的量级要有很大的增长
So that is to say we have to hugely increase the size of this problem

639
00:28:59,265 --> 00:29:03,985
解决问题的时长 或者说翻页次数才会有明显的增加
just for the number of seconds or page turns to appreciably actually increase.

640
00:29:03,986 --> 00:29:06,024
学习编程也是一样
And so as we start to learn about programming,

641
00:29:06,025 --> 00:29:08,659
同样的思路
it's, again, going to be leveraging of this intuition

642
00:29:08,660 --> 00:29:13,560
在提高解决问题和编码的效率上
in order to actually solve problems and code more effectively

643
00:29:13,561 --> 00:29:18,361
比不用这种思路时要强得多
than we might without that intuition alone.

644
00:29:18,365 --> 00:29:20,099
现在换一种更具体的方式
So let's formalize this now.

645
00:29:20,100 --> 00:29:23,513
刚才我们非常直观地解释了如何切割划分 如何解决问题
So that was kind of a very intuitive way of dividing and conquering a problem.

646
00:29:23,516 --> 00:29:25,880
就相当于把书一分为二 撕开
Just kind of made sense to go in the middle, tear it,

647
00:29:25,881 --> 00:29:29,576
然后留下其中一半 再撕开 循环往复
then go to the other half or the other half and tear it again, and so forth.

648
00:29:29,577 --> 00:29:34,600
但对于电脑来说 即便强如Alexa或Google Home 或者其他网站
But a computer, even as cool as Alexa and Google Home and all of this are,

649
00:29:34,601 --> 00:29:36,590
你也不能像跟人说话一样
you can't really just talk to them as another human

650
00:29:36,591 --> 00:29:38,299
告诉电脑怎么执行命令
and have them execute things correctly.

651
00:29:38,300 --> 00:29:41,922
让Siri帮我设个计时器都费劲
I struggle just to get Siri to set a timer on my phone.

652
00:29:41,923 --> 00:29:44,475
时代还没发展到那一步 现在我们依然需要
So we're not quite there yet, so we're still at the age

653
00:29:44,476 --> 00:29:47,341
精确地向电脑发出指令
where we have to be ever so precise with computers,

654
00:29:47,342 --> 00:29:50,963
比如语音激活 或者接下来要说的 伪代码
voice activated or otherwise, and so thus enter pseudocode for now.

655
00:29:50,964 --> 00:29:53,073
伪代码并没有正式的定义
Pseudocode has no formal definition.

656
00:29:53,074 --> 00:29:57,513
它用一种与英语或其他语法类似的表达方式
This is just a way of saying use English-like syntax or any spoken language

657
00:29:57,516 --> 00:30:00,805
使你简洁精确地描述自己的意图
and just express yourself succinctly and correctly

658
00:30:00,806 --> 00:30:03,633
方便电脑 机器人 甚至其他人
so that a computer or a robot or even another person

659
00:30:03,634 --> 00:30:06,125
理解你要表达的意思
can understand what it is you're trying to say.

660
00:30:06,126 --> 00:30:08,574
屏幕上是我写的一个算法
So here, I propose, is an algorithm

661
00:30:08,575 --> 00:30:12,312
按照类似英语语法的伪代码形式 表达了我的意思
written in pseudocode, English-like syntax, that just gets my point across.

662
00:30:12,313 --> 00:30:14,048
当然还有很多别的书写形式
And I could write this in any number of ways.

663
00:30:14,049 --> 00:30:17,230
为了便于讨论 我把这些步骤从0开始标号
I've numbered the steps from zero on up, just for the sake of discussion,

664
00:30:17,231 --> 00:30:19,414
这里就是我刚才所做的事情
but this would seem to capture what I did there.

665
00:30:19,415 --> 00:30:20,750
拿起电话簿
Pick up the phone book.

666
00:30:20,751 --> 00:30:22,363
翻到电话簿中间
Open to the middle of the phone book.

667
00:30:22,364 --> 00:30:23,238
查找姓名
Look at the names.

668
00:30:23,239 --> 00:30:25,740
如果史密斯出现在列表中 则呼叫迈克
If Smith is among the names, call Mike.

669
00:30:25,742 --> 00:30:28,190
否则 如果迈克·史密斯在此位置之前
Else, if Mike Smith is earlier in the book,

670
00:30:28,191 --> 00:30:31,586
则往左 即书的左半部分
go to the left, specifically the middle of the left half of the book,

671
00:30:31,587 --> 00:30:33,443
返回执行步骤二
and then go back to step two.

672
00:30:33,446 --> 00:30:36,050
我刚才就是在不断重复这个过程
Because indeed, I was just doing the same thing again and again,

673
00:30:36,051 --> 00:30:38,299
但它并不是永无止境的
and the reason I wasn't doing it forever was because

674
00:30:38,300 --> 00:30:41,108
因为每次重复之后
every time I repeated myself by opening and tearing,

675
00:30:41,109 --> 00:30:42,590
问题都会减半
I was shrinking the problem.

676
00:30:42,591 --> 00:30:45,432
最终问题总会简化到一定程度
And I can only shrink a problem of some fixed finite size

677
00:30:45,433 --> 00:30:47,459
直到最终我只剩下一页纸为止
so many times until I get just one page,

678
00:30:47,460 --> 00:30:51,609
所以只要重复这个逻辑 查找右半部分或左半部分 或者直接退出
and so if I continue this logic looking to the right or to the left or just quitting,

679
00:30:51,610 --> 00:30:53,995
如果我在最后一页找不到 Mike
if I don't find Mike at all on the last page,

680
00:30:53,996 --> 00:30:57,261
这似乎更准确地捕捉到这段代码
this would seem to capture more precisely that code.

681
00:30:57,262 --> 00:30:59,672
让我们从这里中提取几个概念
Well, let's actually excerpt from this now a few concepts

682
00:30:59,673 --> 00:31:02,511
然后把它应用到实际代码中
and then start to apply them to actual code.

683
00:31:02,514 --> 00:31:06,272
我敢说 这里黄色高亮部分是所有代表动作的动词
Highlighted in yellow here, I dare say, are all of the verbs or actions.

684
00:31:06,273 --> 00:31:09,976
这些都是函数 我将会在这个算法中调用它们
These are the functions, as we're going to start calling them, in this algorithm.

685
00:31:09,977 --> 00:31:12,972
一个函数仅仅是你为了做某事而采取的
A function is just a specific step, a specific action

686
00:31:12,973 --> 00:31:16,132
特定的步骤或特定的动作
you take in order to do something.

687
00:31:16,135 --> 00:31:20,320
就像黄色高亮部分显示的 pick up open to look at call open  quit
And so in yellow here... pick up, open to, look at, call, open, quit

688
00:31:20,323 --> 00:31:23,896
都是代表动作的动词 从现在开始 我称它们为函数
are all actions or verbs. Are henceforth, we'll call them functions.

689
00:31:23,897 --> 00:31:27,800
同时这里高亮显示的 if else if  else if else
Meanwhile, highlighted in yellow here... if, else if, else if, else.

690
00:31:27,801 --> 00:31:30,092
它们开始问问题来
These are kind of starting to ask questions.

691
00:31:30,093 --> 00:31:32,998
如果你对这些语句熟悉的话你会称呼它们为什么
What might these be called if you have some familiarity?

692
00:31:33,419 --> 00:31:33,716
是的
Yes.

693
00:31:33,717 --> 00:31:36,061
如果以前见过其他编程语言的话
Turns out many programming languages, if you've seen any before,

694
00:31:36,062 --> 00:31:37,071
我们通常称它为条件语句
would call these conditions.

695
00:31:37,074 --> 00:31:39,602
他们就像道路上的分叉
They're branches, or proverbial forks in the road.

696
00:31:39,603 --> 00:31:41,310
如果为真 则这么走
If this is true, go this way.

697
00:31:41,311 --> 00:31:45,553
否则 则那么走 或者走第三个或第四个方向
Else, maybe go this other way, or perhaps a third or fourth direction altogether.

698
00:31:45,554 --> 00:31:49,132
同时 如果我们看看这些高亮显示的短句
Meanwhile, if we actually look at these highlighted phrases...

699
00:31:49,133 --> 00:31:51,960
if Smith is among names or if Smith is earlier in book
if Smith is among names or if Smith is earlier in book

700
00:31:51,961 --> 00:31:53,234
or Smith is later in book...
or Smith is later in book...

701
00:31:53,235 --> 00:31:56,866
这些是我们为了作出决定而提的具体问题
these are the specific questions we're asking in order to make that decision.

702
00:31:56,867 --> 00:31:58,739
这些被称为布尔表达式
These are known as Boolean expressions,

703
00:31:58,740 --> 00:32:01,699
源自几百年前一位名叫布尔的绅士
named after a gentleman by the last name of Boole some years ago.

704
00:32:01,700 --> 00:32:03,791
所以布尔表达式是一个仅有是或否、
And so a Boolean expression is just a question

705
00:32:03,794 --> 00:32:06,619
真或假 1或0
that has a yes or no answer, a true false answer,

706
00:32:06,620 --> 00:32:09,379
答案的问题
a one zero answer, if you will.

707
00:32:09,380 --> 00:32:11,912
布尔表达式很好地反映地计算机真正擅长的方面
And that's a nice mapping to what computers are really good at.

708
00:32:11,913 --> 00:32:13,986
你用布尔表达式
So within conditions, you have Boolean expressions

709
00:32:13,987 --> 00:32:17,181
决定你进行的下一步
to decide which fork in the road you want to go down.

710
00:32:17,182 --> 00:32:19,202
最后 在几个地方高亮的
And then lastly, highlighted in yellow here

711
00:32:19,203 --> 00:32:21,752
is go back to step 2
is go back to step 2 in a couple of places.

712
00:32:21,753 --> 00:32:24,464
这是在诱导某种循环
This is inducing some kind of cycle or loop

713
00:32:24,465 --> 00:32:28,306
这是让电脑一遍又一遍地做某件事
that's telling the computer to do something again and again and again.

714
00:32:28,307 --> 00:32:32,152
总之 我们已经在概念上理解 函数 条件语句 布尔表达式 循环
So in short, we have these building blocks already conceptually.

715
00:32:32,153 --> 00:32:34,843
现在 我们可以开始将这些转换为
And it turns out, we can now start to translate these

716
00:32:34,844 --> 00:32:37,112
一种现实的编程语言
to an actual programming language.

717
00:32:37,113 --> 00:32:39,192
在 CS50 中介绍的第一门编程语言是
The first of the languages we'll introduce in CS50

718
00:32:39,193 --> 00:32:40,444
Scratch
is something called Scratch.

719
00:32:40,445 --> 00:32:42,213
它并不是一种像我的英文伪码
Turns out this is not a text based language,

720
00:32:42,214 --> 00:32:44,565
基于文本的编程语言 它是图形化的
like in my English pseudocode there, but it's graphical

721
00:32:44,566 --> 00:32:47,200
它看上去像可以拖放的拼图块
and things look like puzzle pieces that you can drag and drop

722
00:32:47,203 --> 00:32:49,455
如果拖放是合乎逻辑的 它们之间是存在联系
and they interconnect if it makes logical sense to do so.

723
00:32:49,456 --> 00:32:51,947
事实上 你们中的一些人可能在小时候或最近玩过它
And in fact, some of you might have played this back in the day as kids

724
00:32:51,948 --> 00:32:54,739
因为它实际上面向的群体是
or even more recently because it's actually targeted typically

725
00:32:54,740 --> 00:32:56,400
想要在课后学习更多 算法
at students in like after school programs who

726
00:32:56,403 --> 00:33:00,709
计算机思维的学生
just want to learn more methodical, more algorithmic, or computational thinking.

727
00:33:00,710 --> 00:33:04,146
我们将用它来探索不限于前面提到的
And we're going to use it to explore not only these building blocks,

728
00:33:04,147 --> 00:33:05,479
函数 条件语句 布尔表达式 循环
but a few others, as well.

729
00:33:05,480 --> 00:33:09,139
在下周我们将会过渡到 C语言
It turns out in the other languages we'll explore in CS50 and beyond,

730
00:33:09,140 --> 00:33:13,099
并将我们这周用 Scratch 实现的转译到 C 上
are languages like C that we'll actually transition to as quickly as next week,

731
00:33:13,100 --> 00:33:17,119
除了C 语言
to then translate what we do this week in Scratch to next week in C.

732
00:33:17,120 --> 00:33:19,129
我们还会学习 Python JavaScript SQL
And in languages like Python and JavaScript

733
00:33:19,130 --> 00:33:22,189
我们将会后期探索
and SQL, which we'll also explore, do we have other capabilities...

734
00:33:22,190 --> 00:33:24,559
将数据储存在变量中
the ability to store data in variables, so to speak,

735
00:33:24,560 --> 00:33:28,369
使用线程 来计算机一次执行多个命令
to use threads, which means get the computer to do multiple things at once,

736
00:33:28,370 --> 00:33:31,459
使用事件 来检测什么事情正在发生 例如 页面点击
events, to mean listen for things happening, like a click

737
00:33:31,460 --> 00:33:34,789
打字 发语音
on the page or a human typing or even saying something.

738
00:33:34,790 --> 00:33:36,451
我们可以做所有
We'll be able to do all of the things that you

739
00:33:36,452 --> 00:33:38,719
你通过手机看起来理所应当的事情
take for granted in your very own phones.

740
00:33:38,720 --> 00:33:41,529
首先我们将使用 Scratch
And we'll do this first by way of this guy.

741
00:33:41,530 --> 00:33:44,599
Scratch 是 麻省理工媒体实验室
So this is Scratch, the default cat that comes with this programming

742
00:33:44,600 --> 00:33:46,429
默认的编程语言
language from MIT's media lab.

743
00:33:46,430 --> 00:33:49,442
通过 Scratch 我们可以让它 向上
And via Scratch can we start programming him to move up,

744
00:33:49,443 --> 00:33:54,009
向下 向左 向右 说点什么 以及其他的命令
down, left, right, say something, utter something, and other commands all together.

745
00:33:54,010 --> 00:33:57,080
让我们继续下去
In fact, let me go ahead and switch contexts here

746
00:33:57,081 --> 00:34:00,461
我现在给你们看看我第一次用 Scratch 写的东西
to show you the very first thing I ever wrote in Scratch.

747
00:34:00,462 --> 00:34:02,097
那是我读研究生的一天
It was back in the day when I was in graduate school

748
00:34:02,098 --> 00:34:04,162
那时候 Scratch 刚刚被麻省理工学院研究出来
and Scratch had just been invented by MIT.

749
00:34:04,163 --> 00:34:06,079
让我们来打开它
Let me go ahead and open this.

750
00:34:06,080 --> 00:34:09,282
我把它称作 Oscar Time
And I called it Oscar Time.

751
00:34:09,283 --> 00:34:12,212
如果我们能有个志愿者过来一下
And if we could perhaps have a volunteer come on up for just a moment.

752
00:34:12,215 --> 00:34:14,740
你必须要在舞台和互联网上都很自在
You have to be comfortable being on stage and on the internet.

753
00:34:14,744 --> 00:34:15,982
穿白衬衫的怎么样？
How about here in the white shirt?

754
00:34:15,986 --> 00:34:17,089
我看见你举手来
I saw your hand first.

755
00:34:17,090 --> 00:34:18,559
上来吧
Come on down.

756
00:34:18,560 --> 00:34:19,999
这是 Oscar Time
So this is Oscar Time.

757
00:34:20,000 --> 00:34:22,279
他是通过 Scratch 实现的
It's implemented in a language called Scratch.

758
00:34:22,280 --> 00:34:26,389
在那天结束时 函数 循环 条件语句以及一些其他概念
And at the end of the day, all that is underneath the hood of this program

759
00:34:26,390 --> 00:34:30,019
都隐藏在这个程序底下
is functions and loops and conditions and a few other of these concepts.

760
00:34:30,020 --> 00:34:31,139
你好 你叫什么名字
Hi. What's your name?

761
00:34:31,140 --> 00:34:31,785
Aviva David
Aviva.David.

762
00:34:31,786 --> 00:34:32,949
很高兴见到你
Nice to meet you.

763
00:34:32,950 --> 00:34:34,198
请到这里来
Come on over here.

764
00:34:34,918 --> 00:34:37,609
再过一会儿 我将会点击
And in just a moment, I'm going to go ahead and click

765
00:34:37,610 --> 00:34:39,680
屏幕左上角的绿色旗子
the green flag at the top left hand corner,

766
00:34:39,683 --> 00:34:41,084
这将启动这个游戏
which is going to play this game.

767
00:34:41,085 --> 00:34:42,870
我们将会在屏幕上看到说明
And we'll see on the screen the instructions.

768
00:34:47,001 --> 00:34:50,839
歌词大意： 哦 我喜欢垃圾
♪ Oh, I love trash. ♪

769
00:34:50,840 --> 00:34:55,039
任何肮脏 或者尘土飞杨的东西
♪ Anything dirty or dingy or dusty. ♪

770
00:34:55,040 --> 00:34:59,209
任何破烂 腐烂或生锈的东西
♪ Anything ragged or rotten or rusty. ♪

771
00:34:59,210 --> 00:35:03,249
是的 我很喜欢垃圾
♪ Yes, I love trash. ♪

772
00:35:03,250 --> 00:35:05,839
如果你想要看到一些垃圾 看看这个
♪ If you really want to see something trashy, look at this. ♪

773
00:35:05,840 --> 00:35:09,939
我这里有一双破旧的运动鞋
♪ I have here a sneaker that's tattered and worn. ♪

774
00:35:09,940 --> 00:35:13,879
到处是洞 鞋带都被撕破了
♪ It's all full of holes and the laces are torn. ♪

775
00:35:13,880 --> 00:35:18,249
这是我出生那天妈妈送给我的礼物
♪ A gift from my mother the day I was born. ♪

776
00:35:18,250 --> 00:35:21,809
我喜欢它 因为它是垃圾
♪ I love it because it's trash. ♪

777
00:35:21,810 --> 00:35:26,189
哦 我喜欢垃圾
♪ Oh, I love trash. ♪

778
00:35:26,190 --> 00:35:30,419
任何肮脏 或者尘土飞杨的东西
♪ Anything dirty or dingy or dusty. ♪

779
00:35:30,420 --> 00:35:34,729
任何破烂 腐烂或生锈的东西
♪ Anything ragged or rotten or rusty. ♪

780
00:35:34,730 --> 00:35:37,829
是的 我喜欢来及
♪ Yes, I love trash. ♪

781
00:35:37,830 --> 00:35:41,149
这是一些更烂的东西
♪ Here's some more rotten stuff. ♪

782
00:35:41,150 --> 00:35:44,859
我这儿有一些13个月前的报纸
♪ I have here some newspaper 13 months old. ♪

783
00:35:44,860 --> 00:35:47,441
好的 各位 为 Aviva 的上台而鼓掌
All right. Everybody, give a round of applause for Aviva for coming on up.

784
00:35:47,442 --> 00:35:48,290
谢谢你
Thank you.

785
00:35:48,290 --> 00:35:48,745
Aviva
Here.

786
00:35:48,746 --> 00:35:49,704
这是给你的
Aviva.

787
00:35:52,299 --> 00:35:53,719
CS50 弹力球
A little CS50 stress ball.

788
00:35:53,720 --> 00:35:56,739
我想说 如果厌倦了这首歌
So suffice it to say, if you're tired of this song,

789
00:35:56,740 --> 00:36:01,171
想想在我花了8个小时调试和构建这个程序后是多么累
consider how tired I was eight hours later while debugging and building this program.

790
00:36:01,172 --> 00:36:02,754
但想想我们刚才看到了什么
But consider what it is we just saw.

791
00:36:02,755 --> 00:36:06,094
这是一个伴随着动画和音乐的交互式游戏
It's this interactive game and stuff is animated and music is playing.

792
00:36:06,095 --> 00:36:10,120
但是如果你专注于拆解 也就是说 这个程序
But if you focus on decomposing, so to speak, this program into just

793
00:36:10,121 --> 00:36:14,144
变成了基本的构建块 这是对一些低层级
basic building blocks, this is just kind of a big abstraction over some lower

794
00:36:14,145 --> 00:36:15,919
功能的抽象化实现
level pieces of functionality.

795
00:36:15,920 --> 00:36:17,220
这里有一个垃圾桶
Like this trash can here.

796
00:36:17,224 --> 00:36:19,369
现在这只是一张照片
At the moment, it's just a picture, and on occasion,

797
00:36:19,370 --> 00:36:22,119
当 Aviva 把东西丢进垃圾桶 盖子弹起
as soon as Aviva dropped something into the trash, the lid came up

798
00:36:22,120 --> 00:36:25,219
Oscar 出来 并说一些话 然后他又回去
and Oscar came out, he said something, and then he went back down.

799
00:36:25,220 --> 00:36:27,259
但是这个动画太简单了
But that animation is super simplistic.

800
00:36:27,260 --> 00:36:32,029
它只是一系列有步骤地循环播放图像
It was just a sequence of 1, 2, 3, or so images displaying and then

801
00:36:32,030 --> 00:36:34,459
来创造动画
going back down to create the illusion of animation.

802
00:36:34,460 --> 00:36:36,829
同时 每次 Oscar 说些什么的时候
Meanwhile, every time Oscar said something,

803
00:36:36,830 --> 00:36:39,859
会在所谓的变量中记录她的分数
that was keeping track of her score in what's called a variable.

804
00:36:39,860 --> 00:36:43,522
在代数中 你有变量 x y z 但是在编程中 也有同样的概念
In algebra, you have x and y and z, but in programming, you have the same idea,

805
00:36:43,523 --> 00:36:46,069
但更多的是用描述性的词语来称呼它们
but it's generally more useful to call them more descriptively,

806
00:36:46,070 --> 00:36:47,080
就像 score
like your score.

807
00:36:47,081 --> 00:36:49,159
所以在这个游戏中可能有一个变量叫 socre
And so there's probably a variable in this game called

808
00:36:49,160 --> 00:36:51,829
用来记录有多少次 Aviva
score that was just keeping track of how many times

809
00:36:51,830 --> 00:36:53,779
把东西丢进来垃圾桶
Aviva had dropped something into the trash.

810
00:36:53,780 --> 00:36:57,600
同时 垃圾本身 鞋子 和报纸
Meanwhile, the trash itself and the shoe and the newspaper...

811
00:36:57,603 --> 00:37:01,009
等其他东西从屏幕上方的随机位置
and even more things happen eventually... were falling from the sky

812
00:37:01,010 --> 00:37:04,219
掉落下来
at sort of random locations, and that's because I programmed the game

813
00:37:04,220 --> 00:37:06,625
这是因为我设置了垃圾掉落的方式
to sort of start the trash here or over here,

814
00:37:06,626 --> 00:37:09,571
以让游戏变得更有挑战性
just to make it a little more challenging as the game picked up.

815
00:37:09,572 --> 00:37:12,079
事实上 随着时间的推移 垃圾下落的速度开始变得越来越快
And in fact, things start falling faster and faster over time,

816
00:37:12,080 --> 00:37:15,003
就像一个典型的游戏 越玩越困难
like a typical game, getting more and more difficult.

817
00:37:15,004 --> 00:37:17,264
那么我们怎么才能做到这样的事情呢
So how do we get to something like that?

818
00:37:17,265 --> 00:37:19,669
让我们继续打开 Scratch
Well, let me go ahead and open up Scratch itself

819
00:37:19,670 --> 00:37:21,720
介绍一下页面布局
and introduce the environment.

820
00:37:21,721 --> 00:37:24,739
在 Scratch 中 可以分为三个区域
So in Scratch, you essentially have three general areas.

821
00:37:24,740 --> 00:37:27,199
因为 Scratch 是基于网络的 你可以在任何一台电脑上实现
And it's web based, and so you can do this on any computer.

822
00:37:27,200 --> 00:37:30,049
在左边 有些我之前提到的
And in the left hand side here, you have those puzzle pieces

823
00:37:30,050 --> 00:37:31,459
拼图
to which I referred earlier.

824
00:37:31,460 --> 00:37:36,679
这些拼图都对应着相应的函数 循环 条件 变量
These puzzle pieces are all mapping to functions or loops or conditions

825
00:37:36,680 --> 00:37:38,499
就像我们之前所看到的
or variables, things that we saw before,

826
00:37:38,500 --> 00:37:41,790
等会
and I'm going to able to drag and drop them into the middle in order

827
00:37:41,791 --> 00:37:43,579
我要把拼图拖到中间
to interconnect them and write my program,

828
00:37:43,580 --> 00:37:44,855
把它们和我写的程序链接在一起
which we'll do in just a moment.

829
00:37:44,856 --> 00:37:48,809
同时 你可以让 Scratch
Meanwhile, Scratch lives in this stage, this world, where he can move up,

830
00:37:48,810 --> 00:37:49,790
向上 向下 向左 向右
down, left, right.

831
00:37:49,791 --> 00:37:51,189
你可以改变 Scratch 的外形
You can change what Scratch looks like.

832
00:37:51,190 --> 00:37:53,839
为了让多个事件同时发生
You can add other characters, otherwise known as sprites,

833
00:37:53,840 --> 00:37:55,602
你可以添加其他字符 或者称其为精灵
in order to have multiple things happening at once.

834
00:37:55,603 --> 00:37:57,160
当然 你也可以全屏显示
And of course, you can fullscreen it.

835
00:37:57,161 --> 00:38:00,949
所以 刚才的 Oscar Time 游戏事实上是一大群精灵
And so the Oscar Time game a moment ago was actually a whole bunch of sprites.

836
00:38:00,950 --> 00:38:02,789
Oscar 的垃圾是一只精灵
Oscar's trash can was one.

837
00:38:02,790 --> 00:38:05,035
每一件垃圾都是一只精灵
Each piece of trash was another sprite.

838
00:38:05,036 --> 00:38:07,589
报纸是一只精灵 其他的也是
The newspaper was a sprite, and so forth.

839
00:38:07,590 --> 00:38:11,731
它们中的每一个都是同时允许的独立程序
So each of them were separate programs running in parallel at the same time.

840
00:38:11,732 --> 00:38:13,537
让我们做点什么吧
So let's actually make him do something.

841
00:38:13,538 --> 00:38:17,309
比如说我跳转到 events
It turns out that if I jump down to, say, events,

842
00:38:17,310 --> 00:38:19,346
我将会看到最有力的一块：
I'm going to see one of the most powerful blocks

843
00:38:19,347 --> 00:38:22,539
when green flag clicked
from the get go, which is this when green flag clicked.

844
00:38:22,540 --> 00:38:24,594
这就是我刚刚和 Aviva
That's indeed how I started the game with Aviva,

845
00:38:24,595 --> 00:38:27,799
通过点击上方的绿色旗帜开始游戏的方式
by clicking just above Scratch's world this green flag.

846
00:38:27,800 --> 00:38:29,516
如果你想停止
And if I wanted to stop it, as I did,

847
00:38:29,517 --> 00:38:31,651
你需要点红色标志
you can click the red stop sign to say stop.

848
00:38:31,652 --> 00:38:35,269
同时 我可以持续拖放
Meanwhile, the green flag, I can constantly

849
00:38:35,270 --> 00:38:37,759
绿色的旗帜
listen for by dragging and dropping this puzzle piece.

850
00:38:37,760 --> 00:38:40,249
当时绿色旗帜被点击后 我想做什么呢
When the green flag is clicked, what do I want to do?

851
00:38:40,250 --> 00:38:42,131
让我们来看一看
Well, let me go up to looks.

852
00:38:42,132 --> 00:38:43,619
这里分为几种不同的类别
And these are just different categories.

853
00:38:43,620 --> 00:38:45,640
我们可以滑动鼠标看看不同颜色所代表的类别
And we can scroll through all the different colorful blocks,

854
00:38:45,641 --> 00:38:47,779
它们所发挥的作用正如它们所显示的一样
but they pretty much just do what they say.

855
00:38:47,780 --> 00:38:51,909
我往下看一看 我知道有个功能块叫 say
I'm going to go under looks, where I know there to be a block that's called say,

856
00:38:51,910 --> 00:38:54,852
我将要在箱子中输入最典型的计算机科学的话语
and I'm going to go ahead and type the most canonical computer science thing

857
00:38:54,853 --> 00:38:56,605
hello world
hello world in this box.

858
00:38:56,606 --> 00:38:59,153
所以请注意函数本身实际上可以接受
So notice that functions themselves can actually

859
00:38:59,154 --> 00:39:02,275
这个函数的输入与输出
take inputs and the input to this function, say,

860
00:39:02,276 --> 00:39:03,619
比如说我输入 hello world
is going to be hello world.

861
00:39:03,620 --> 00:39:06,497
如果我点击绿色旗子
If I now go over to the green flag and click it...

862
00:39:07,070 --> 00:39:08,200
它会输出 hello world
hello world.

863
00:39:08,201 --> 00:39:08,598
好的
All right.

864
00:39:08,599 --> 00:39:11,574
没那么困难 也没很有趣
So not all that difficult. Not all that interesting.

865
00:39:11,575 --> 00:39:15,550
但它确实完成来任务 所以我的程序就是这样
But it actually got the job done, and so my program is indeed just this.

866
00:39:15,551 --> 00:39:17,599
好的 我怎么才能让这件事更有趣了
Well, how might I make this a little more interesting?

867
00:39:17,600 --> 00:39:20,269
输出 hello world 并没有那么吸引人
Just saying, hello world all the time isn't all that compelling.

868
00:39:20,270 --> 00:39:21,160
你们知道怎么做吗
Well, you know what?

869
00:39:21,160 --> 00:39:21,710
让我想想
Let me think.

870
00:39:21,711 --> 00:39:23,045
让我们撤销这步
Let me undo this.

871
00:39:23,046 --> 00:39:24,919
让我们滑到 sensing
Let me scroll down to sensing.

872
00:39:24,920 --> 00:39:26,419
请注意这个
And notice this.

873
00:39:26,420 --> 00:39:28,995
函数也可以接受键盘输入的值
Functions can also take input from a human

874
00:39:28,996 --> 00:39:32,809
函数可以返回一个值 一个所谓的返回值
and functions can hand you back a value, a so-called return value.

875
00:39:32,810 --> 00:39:35,629
这里有个功能块关于问什么的
So this block here, ask something... by default, it says,

876
00:39:35,630 --> 00:39:37,039
what's your name and weight...
what's your name and weight...

877
00:39:37,040 --> 00:39:39,889
是另一个内置在 Scratch 中函数
is another function built into Scratch that allows me to do this.

878
00:39:39,890 --> 00:39:41,959
所以我要把它拖到中间
So I'm going to go ahead and drag this here

879
00:39:41,960 --> 00:39:44,356
我会让他说 你叫什么名字
and I'm going to let it say, what's your name?

880
00:39:44,357 --> 00:39:47,115
注意这里有有一个特殊功能块
Notice now that below this block is a special block,

881
00:39:47,116 --> 00:39:49,244
无论什么它都会返回值
whatever it is the block returns.

882
00:39:49,245 --> 00:39:52,099
所以答案是我们将要输入的内容
So answer is whatever the human is going to type in.

883
00:39:52,100 --> 00:39:56,599
如果我现在想说我们输入了什么  让我们
And if I want to now say what the human typed in, let me go again to looks.

884
00:39:56,600 --> 00:39:57,600
去往 say 功能块
Go to say.

885
00:39:57,601 --> 00:39:59,689
注意这些功能块之间又磁力
And notice that these blocks are kind of magnetic.

886
00:39:59,690 --> 00:40:00,809
它们想要吸在一起
They want to snap together.

887
00:40:00,810 --> 00:40:02,584
所以我会把它放在后面
So I'm going to go ahead and let go there.

888
00:40:02,585 --> 00:40:05,760
如果我回到 sensing 板块 拖动 answer
And if I go back to sensing and grab answer,

889
00:40:05,763 --> 00:40:08,365
注意即使 answer 和 say 不是同样大小
notice that even though it's not quite the same size,

890
00:40:08,366 --> 00:40:09,704
但它会自动填充
it's going to grow to fill,

891
00:40:09,705 --> 00:40:13,115
现在 我可以让我的程序问用户的名字是什么了
and now, I can have my program ask the user what his or her name is

892
00:40:13,116 --> 00:40:15,469
然后说出答案
and then say whatever that answer is.

893
00:40:15,470 --> 00:40:18,760
让我继续 停止 再点击播放
So let me go ahead and stop and click play again.

894
00:40:18,761 --> 00:40:21,559
注意程序在问我的名字 让我输入 David
Notice it's asking me for my name, so let me go ahead and type in David.

895
00:40:21,560 --> 00:40:22,406
回车
Enter.

896
00:40:22,737 --> 00:40:23,060
OK
OK.

897
00:40:23,061 --> 00:40:25,289
打招呼的方式有一点奇怪
It's a little weird way to greet someone.

898
00:40:25,290 --> 00:40:26,400
David
David.

899
00:40:26,403 --> 00:40:29,029
所以把它弄干净点就好了
So it'd be nice to clean that up a bit.

900
00:40:29,030 --> 00:40:29,870
所以你知道吗
So you know what?

901
00:40:29,871 --> 00:40:31,963
我知道是因为我之前玩过
I know this only from having poked around before.

902
00:40:31,964 --> 00:40:33,769
不是所有这些都是显而易见的
Not all of this is obvious at first glance.

903
00:40:33,770 --> 00:40:36,894
但事实证明 在操作符下 类别
But it turns out that under operators, the category,

904
00:40:36,895 --> 00:40:39,571
这里有个功能块 join apple and banana
there's this thing here... join apple and banana.

905
00:40:39,572 --> 00:40:40,880
它们只是默认值
Which are just default values.

906
00:40:40,883 --> 00:40:42,051
你可以更改它们
You can change them.

907
00:40:42,052 --> 00:40:43,219
因为我接下来想做什么
Because what do I want to do?

908
00:40:43,220 --> 00:40:48,259
我想让它说你好 David 或者其他什么人 所以我要输入hello 逗号
I want to say hello, David, or whoever, so I kind of want to say hello, comma,

909
00:40:48,260 --> 00:40:50,280
然后是David...和任何键盘输入的内容
and then, David... whatever the human typed in.

910
00:40:50,281 --> 00:40:51,666
这是join函数做的工作
And that's what join lets you do.

911
00:40:51,667 --> 00:40:55,470
它帮你把两个词组连接起来
It lets you join or concatenate two phrases that are somehow

912
00:40:55,471 --> 00:40:56,726
这两个词组由你或用户提供
provided by you or the user.

913
00:40:56,727 --> 00:40:59,229
让我把answer模块移出来
So let me pull this out, the answer.

914
00:40:59,230 --> 00:41:01,192
接着继续把join模块移进去
Let me go ahead and grab the join block.

915
00:41:01,193 --> 00:41:03,189
可以看到 空间会扩大到足以容纳新的模块
Notice it, too, is going to grow to fill.

916
00:41:03,190 --> 00:41:09,549
接着继续输入 hello 逗号 空格 然后把answer模块拖进来
Let me go ahead and say, hello, comma, space, and now, drag answer into there.

917
00:41:09,550 --> 00:41:12,440
注意这种嵌套结构
And notice this nesting.

918
00:41:12,441 --> 00:41:13,081
就像地图一样
Just like in math.

919
00:41:13,082 --> 00:41:14,899
这种是函数的嵌套
This nesting of functions.

920
00:41:14,900 --> 00:41:19,256
我可以先以hello和answer模块作为join函数的输入
I can first join hello and answer by taking those two things as input

921
00:41:19,257 --> 00:41:21,292
然后把结果作为输入传递给say函数
and then pass them to say as another input

922
00:41:21,293 --> 00:41:22,939
因为它们覆盖在其他模块的上面
because these things are layered on top.

923
00:41:22,940 --> 00:41:26,872
现在我停下来重新运行 输入David
And so now, if I stop this and play it again and say, David...

924
00:41:26,873 --> 00:41:27,790
它输出了hello David
hello, David.

925
00:41:27,791 --> 00:41:31,239
我们目前就完成了一个更有意思的交互程序了
Now, we have the makings of a more interesting interactive program

926
00:41:31,240 --> 00:41:32,799
而不仅是硬编码
that isn't just hardcoded.

927
00:41:32,800 --> 00:41:38,899
当然它还不像先前Oscar Time一样可以发出声音
Of course, it's not nearly as audible as something like Oscar Time a moment ago.

928
00:41:38,900 --> 00:41:39,829
所以接下来我就来实现这个功能
So let me go ahead and do this.

929
00:41:39,830 --> 00:41:44,184
我重新写一个程序 把Scratch当作一只猫来对待
Let me start over altogether and treat Scratch like the cat he is

930
00:41:44,185 --> 00:41:46,169
让它发出喵的声音
and just start the sound called meow.

931
00:41:46,170 --> 00:41:48,669
这里有一类模块被称为sound
So it turns out there's a category of blocks called sound,

932
00:41:48,670 --> 00:41:51,341
这个模块可以发出一些预设的声音
and within sound, there is play some default sounds.

933
00:41:51,342 --> 00:41:52,939
让它发出喵
So start sound meow.

934
00:41:52,940 --> 00:41:54,984
现在变得有点可爱了
And now, things will get a little cuter.

935
00:41:57,575 --> 00:41:58,664
再来一次
And now, again.

936
00:42:00,118 --> 00:42:03,739
我可以一直站在这里 通过按按钮发出猫叫
And I can kind of simulate a cat by [MEOW] standing here for a while

937
00:42:03,740 --> 00:42:05,449
来模拟一只猫
and keeping to click this button.

938
00:42:05,450 --> 00:42:05,923
但是你知道吗
But you know what?

939
00:42:05,924 --> 00:42:08,373
让它喵好几次 这样看起来更逼真一点
Let me make him meow few times because that's more realistic.

940
00:42:08,374 --> 00:42:10,119
让我加进来第二个和第三个模块
So let me grab a second one and a third one.

941
00:42:10,120 --> 00:42:12,109
有无穷多的模块任你使用
And you can get this infinite supply of blocks.

942
00:42:12,110 --> 00:42:12,921
点击开始 Let me hit play.

943
00:42:17,030 --> 00:42:18,022
看起来像一个bug
Seems like a bug.

944
00:42:18,023 --> 00:42:18,613
再试一次
Let's try again.

945
00:42:18,614 --> 00:42:19,113
开始
Play.

946
00:42:21,590 --> 00:42:24,109
这是我第一个bug 或者说错误
This is my first bug, or mistake.

947
00:42:24,110 --> 00:42:25,253
程序看起来没错
This looks correct.

948
00:42:25,254 --> 00:42:29,239
点击绿色小旗时 开始播放喵 开始播放喵
It says when green flag clicked, start sound meow, start sound meow,

949
00:42:29,240 --> 00:42:30,559
开始播放喵 start sound meow.

950
00:42:30,560 --> 00:42:33,001
那为什么只听到一个喵呢
Why am I only hearing one meow?

951
00:42:34,030 --> 00:42:34,998
是啊
Yeah.

952
00:42:35,280 --> 00:42:39,000
三个喵同时或者接近同时播放了
They're kind of at the same time or so close to the same time

953
00:42:39,001 --> 00:42:41,651
声音之间相互重叠和覆盖了
that the sounds are kind of tripping over each other and just overlapping,

954
00:42:41,652 --> 00:42:42,083
对吧
right?

955
00:42:42,084 --> 00:42:44,259
这个模块仅仅是开始播放喵
The block literally says, start sound meow.

956
00:42:44,260 --> 00:42:45,659
但计算机运行的很快
But computers are really fast.

957
00:42:45,660 --> 00:42:48,309
如果你听过兆赫兹这个测量单位
If you've heard of the expression gigahertz, that's a unit of measure.

958
00:42:48,310 --> 00:42:52,839
如果你的电脑里有一块兆赫兹级别的CPU 中央处理器 或者大脑
And if your computer has a one gigahertz CPU, central processing unit, or brain,

959
00:42:52,840 --> 00:42:56,199
这意味着它每秒钟能做十亿件事情
that means it can literally do like a billion things per second.

960
00:42:56,200 --> 00:42:59,723
那它自然能以超快的速度播放三个喵了
It can certainly start three sounds super fast.

961
00:42:59,724 --> 00:43:02,765
如果它们被一个接着一个的高效执行
And if they're effectively all happening one after the other

962
00:43:02,766 --> 00:43:05,829
在前一个声音结束前 第二个声音就开始了
before the sound even finishes, you're just hearing one net effect.

963
00:43:05,830 --> 00:43:07,129
所以我们怎么修复这个问题 So how can we fix this?

964
00:43:07,130 --> 00:43:10,451
好吧 我可以用这个模块来修复这个问题
Well, I can actually go and fix this with this block here...

965
00:43:10,452 --> 00:43:12,771
播放喵并等到其结束
play sound meow until done.

966
00:43:12,772 --> 00:43:16,110
播放喵并等到其结束
Play sound meow until done.

967
00:43:16,111 --> 00:43:16,848
现在
And now.

968
00:43:19,488 --> 00:43:19,850
好
OK.

969
00:43:19,851 --> 00:43:21,529
这只猫听起来好像不太开心
It's a little unhappy, this particular cat,

970
00:43:21,530 --> 00:43:23,160
但至少程序没问题了
but at least it's now more correct.

971
00:43:23,161 --> 00:43:25,959
如果我到control面板...
And, as it turns out, if I go to control...

972
00:43:25,960 --> 00:43:26,306
你知道吗
you know what?

973
00:43:26,307 --> 00:43:29,283
这里有一个模块...等待几秒钟
There's this block here... wait some number of seconds.

974
00:43:29,284 --> 00:43:31,479
接着我把这个模块放到这里
I can go ahead and insert this here.

975
00:43:31,480 --> 00:43:33,099
再放一个到这里
Let me do another one here.

976
00:43:33,100 --> 00:43:34,306
现在 点击开始
And now, hit play.

977
00:43:38,702 --> 00:43:40,709
还不错吧
You know, it's not bad.

978
00:43:40,710 --> 00:43:43,769
现在听起来更逼真了
It now sounds a little more realistic.

979
00:43:43,770 --> 00:43:46,074
但如果我要再来几次...你知道吗
But honestly, if I keep doing this... or you know what?

980
00:43:46,075 --> 00:43:48,329
你可以右击或者按住ctrl点击模块
You can actually right click or control click on blocks,

981
00:43:48,330 --> 00:43:51,592
选择duplicate 就能在你需要的时候复制它们
duplicate them, and just copy and paste even more if you want them.

982
00:43:51,593 --> 00:43:55,979
如果我这样做 它就会运行6次
So if I were to do this, now, it's just going to go six times.

983
00:43:55,980 --> 00:43:58,072
我可以再复制一次让它就会运行12次
And then I could copy it again and go 12 times.

984
00:43:58,073 --> 00:43:59,558
但这里应该有更好的方法 对吧
But there's got to be a better way, right?

985
00:43:59,559 --> 00:44:01,019
这是不好的编程方式
This is now bad programming.

986
00:44:01,020 --> 00:44:02,309
这是不好的设计
This is bad design.

987
00:44:02,310 --> 00:44:05,205
因为我仅仅是做了复制和粘贴
Because I'm literally copying and pasting, albeit, graphically.

988
00:44:05,206 --> 00:44:07,709
但我们已经见过一种模块
But we've already seen a building block with which

989
00:44:07,710 --> 00:44:09,929
可以用它实现更好的设计
we can design this program better.

990
00:44:09,930 --> 00:44:11,729
虽然现在的程序没有错误 但它的设计并不好
It's correct, but it's not well designed.

991
00:44:11,730 --> 00:44:15,502
需要哪种模块我可以做出更简洁的设计
What would the building block be that I need to make this a little cleaner?

992
00:44:16,212 --> 00:44:16,860
好的
OK.

993
00:44:16,860 --> 00:44:17,400
一个for循坏
A four loop.

994
00:44:17,401 --> 00:44:18,689
在Scratch中并不存在
Doesn't quite exist in Scratch.

995
00:44:18,690 --> 00:44:21,811
但一个循环就是在重复一件事
But a loop fundamentally does something cyclically.

996
00:44:21,812 --> 00:44:24,440
如果我在control面板中找一找
And indeed, if I go under control and start poking around,

997
00:44:24,441 --> 00:44:27,449
你会看到有一些可能有用的模块
you'll notice that there's a few blocks that might apply here.

998
00:44:27,450 --> 00:44:29,552
repeat模块 重复一定次数
There's the repeat block some number of times

999
00:44:29,553 --> 00:44:32,990
或者forever模块 都看起来像循环
or the forever block, both of which sound like loops, or cycles.

1000
00:44:32,991 --> 00:44:35,999
现在有足够的把握 让我把不需要的模块
So sure enough, let me go ahead here and I can throw away blocks

1001
00:44:36,000 --> 00:44:37,649
拖到左边扔掉
by just dragging them to the left.

1002
00:44:37,650 --> 00:44:40,619
接着把这个模块移出来
Let me pull this out for a second.

1003
00:44:40,620 --> 00:44:44,999
一直 播放这个声音 然后等待1秒钟
And then just say forever play this sound, and then wait one second.

1004
00:44:45,000 --> 00:44:47,808
现在 我的程序看起来是这样
So now, my program looks like this.

1005
00:44:54,730 --> 00:44:57,309
我们没法在严格意义上验证它是否正确
You know, we'll never know if it's technically correct because it's just

1006
00:44:57,310 --> 00:45:00,669
因为它只是一直运行下去 但它看起来没有问题
going to go, we think, forever, but it looks like this is correct.

1007
00:45:00,670 --> 00:45:02,944
而且现在代码量更少 更容易维护
And it was a lot less code and it's a lot easier

1008
00:45:02,945 --> 00:45:05,799
如果我想让它听起来像打瞌睡
to maintain because if I want him to kind of get sleepy,

1009
00:45:05,800 --> 00:45:09,300
我把这里改成2秒
I can then maybe say two seconds instead.

1010
00:45:11,600 --> 00:45:14,269
程序运行时 我们的改动也是立即生效的
You know, and we can adjust this on the fly as we go.

1011
00:45:14,270 --> 00:45:16,851
我们开始把这些功能组合起来
But let's start to combine some of these ideas now

1012
00:45:16,852 --> 00:45:20,003
而且改变最终效果的样子
and change what it is the ultimate effect is.

1013
00:45:20,004 --> 00:45:22,849
接着我打开一个提前做好的例子
Let me go ahead and open an example I made in advance.

1014
00:45:22,850 --> 00:45:24,830
这个被称为Count Zero
This one's called Count Zero.

1015
00:45:24,831 --> 00:45:27,929
我们后面会把它放到网站上 你可以在课下试一试
And we'll put this on the website later so that you can play with if you like.

1016
00:45:27,930 --> 00:45:29,766
这是数羊的某种反面
And this is kind of the opposite of counting sheep.

1017
00:45:29,767 --> 00:45:32,704
不同于我或者睡觉的人数羊
Rather than me or the person sleeping counting sheep,

1018
00:45:32,705 --> 00:45:34,892
这只羊会自己数数
this sheep will count itself.

1019
00:45:34,893 --> 00:45:37,008
让我点击开始
So let me go ahead and just play.

1020
00:45:37,603 --> 00:45:42,259
可爱 他开始自己数数了 1 2 3
And adorably, he seems to just be counting 1, 2, 3.

1021
00:45:42,260 --> 00:45:43,339
但为什么会这样呢 But why is that?

1022
00:45:43,340 --> 00:45:44,959
他看起来会一直数下去
He's just going to count forever.

1023
00:45:44,960 --> 00:45:47,869
我们看看程序是如何让他一直数数的
But let's look at the blocks with which he is counting forever.

1024
00:45:47,870 --> 00:45:50,051
当绿色小旗被点击时 设置counter
When green flag clicked, set counter.

1025
00:45:50,052 --> 00:45:52,276
黄色框框是我们称之为变量的东西
Turns out this orange box is what we called a variable.

1026
00:45:52,277 --> 00:45:54,109
在代数中 它就像x y或z
So in algebra, it would be like x or y or z.

1027
00:45:54,110 --> 00:45:55,377
但这些名称不能描述它的作用
Those are not descriptive.

1028
00:45:55,378 --> 00:45:59,003
我为这个变量起名counter 其实我也可以起名x y或z
I called this one counter instead, but I could have called it x or y or z.

1029
00:45:59,004 --> 00:46:03,619
然后我一直输出counter的值 显示1秒 接着等待1秒
And then I forever say the counter for one second, then wait one second,

1030
00:46:03,620 --> 00:46:05,449
接下来的模块改变counter的值
and then change the counter by one,

1031
00:46:05,450 --> 00:46:06,949
作用是增加变量的值
which technically means just increment it.

1032
00:46:06,950 --> 00:46:07,969
在变量上加1
Add 1 to it.

1033
00:46:07,970 --> 00:46:10,872
因此这只羊就会往上数数
And the sheep is just going to therefore count up and up and up.

1034
00:46:10,873 --> 00:46:12,486
有一点单调 但是
Now, this is a little tedious, but that's

1035
00:46:12,487 --> 00:46:15,600
这就是让这只羊入睡的关键
kind of the point of counting sheep, of course, to fall asleep.

1036
00:46:15,603 --> 00:46:19,382
但如果这只羊加快数数的速度呢
But what if the sheep actually kind of liked counting a little faster?

1037
00:46:19,383 --> 00:46:21,805
让我到operator面板这里
Well, let me go under operators here.

1038
00:46:21,806 --> 00:46:25,384
乘法运算听起来可以让我们更快的计数
Multiplication sounds like it could get us places quicker.

1039
00:46:25,385 --> 00:46:27,799
接下来到variables面板
And let me go ahead and go to variables.

1040
00:46:27,800 --> 00:46:30,499
不用每次都在counter上增加1
And instead of changing the counter by one,

1041
00:46:30,500 --> 00:46:32,829
而是直接把它设置成另一个值
let me go ahead and just keep setting it to something else.

1042
00:46:32,830 --> 00:46:34,128
现在把这个拖到这里
So let me drag and drop this.

1043
00:46:34,129 --> 00:46:38,899
把counter的值设置为一个数乘以一个数
Set the counter equal to something times something, specifically

1044
00:46:38,900 --> 00:46:45,369
counter乘2 因此counter的值会一直翻倍 翻倍 再翻倍
the counter times two, thereby doubling, doubling, doubling, doubling.

1045
00:46:45,370 --> 00:46:47,720
此时应该会以更快的速度增长了
That would seem to grow, so to speak, a lot faster.

1046
00:46:47,721 --> 00:46:48,702
看看效果
Let's see.

1047
00:46:49,940 --> 00:46:54,201
1 2 4
1, 2, 4.

1048
00:46:54,744 --> 00:46:57,341
此时他数的更快了 但仍有点单调
So he's counting faster, but it's still kind of tedious.

1049
00:46:57,342 --> 00:46:59,179
如果他不这样呢 What if we instead do this?

1050
00:46:59,180 --> 00:47:03,199
我们不再等待1秒 接着看看
Let's stop waiting and let's go ahead and, with the looks,

1051
00:47:03,200 --> 00:47:07,499
不用显示1秒counter的模块了 用更短时间的显示模块
not say counter for one second, but let's just quickly say counter.

1052
00:47:07,500 --> 00:47:08,839
我准备显示counter
So I'm going to say the counter.

1053
00:47:08,840 --> 00:47:09,600
噢
Whoops.

1054
00:47:09,830 --> 00:47:14,040
我准备显示counter 然后马上让它翻倍
I'm going to say the counter and then I'm going to set it to itself times 2.

1055
00:47:14,041 --> 00:47:15,099
我们目前的程序
So here's where we're at.

1056
00:47:15,100 --> 00:47:19,489
先初始化 把counter的值设为1 显示 然后翻倍
Initialize, or set the counter to 1 initially, say it, then double it,

1057
00:47:19,490 --> 00:47:22,430
翻倍 再翻倍 同时一直显示
then double it, then double it, saying it along the way.

1058
00:47:22,431 --> 00:47:23,502
运行一下
So here we go.

1059
00:47:24,219 --> 00:47:25,704
印象深刻
That's impressive.

1060
00:47:27,349 --> 00:47:31,697
现在这只羊数到10^60了
So now the sheep has counted up to 10 to the 60th so far.

1061
00:47:32,860 --> 00:47:34,760
数到10^100了
10 to the 100th.

1062
00:47:34,761 --> 00:47:35,269
好
OK.

1063
00:47:35,270 --> 00:47:39,933
现在对话框已经装不下这个数了 但他仍在继续数
Now, it doesn't even fit in the speech bubble, but he's still going.

1064
00:47:39,934 --> 00:47:41,811
他能数到多大呢
How high can he go?

1065
00:47:41,812 --> 00:47:45,906
你在计算机中能数到的最大的一个数是多少
What's the biggest number you can count to in a computer?

1066
00:47:46,483 --> 00:47:48,497
有人想猜一猜吗
Anyone want to guess?

1067
00:47:50,170 --> 00:47:51,600
等会就会数到那个数了
Could be here a while.

1068
00:47:51,965 --> 00:47:54,669
现在是10^270了
10 to the 270th now.

1069
00:47:54,670 --> 00:47:56,904
你能数到多大 或者
How high can you count, or rather...

1070
00:47:58,111 --> 00:47:58,601
好吧
OK.

1071
00:47:58,602 --> 00:48:01,522
不用猜了 我们把它称为无穷大
So we gave up and just called it infinity.

1072
00:48:01,523 --> 00:48:03,954
在计算机中无穷大是一个确定的数
So it turns out infinity does have a precise value...

1073
00:48:03,955 --> 00:48:06,232
大概是10^250吧
10 to the 250th or so.

1074
00:48:06,233 --> 00:48:07,689
数到这个数会发生什么呢
But what happens here?

1075
00:48:07,690 --> 00:48:10,022
因为计算机实际上
Well, because computers, at the end of the day,

1076
00:48:10,023 --> 00:48:12,117
用数字来存储信息
are just storing information digitally

1077
00:48:12,118 --> 00:48:14,578
信息实际上是物理设备中存储的数字
but that information digitally has to be physically stored

1078
00:48:14,579 --> 00:48:17,529
用电和底层的开关 我们称之为晶体管
using electricity, using these lower level switches called transistors.

1079
00:48:17,530 --> 00:48:20,739
重要的是 我的手机 电脑等设备
At the end of the day, my phone, my laptop, whatever device in question

1080
00:48:20,740 --> 00:48:23,049
只有数量有限的晶体管
only has a finite amount of those things.

1081
00:48:23,050 --> 00:48:24,824
就像我的手只有有限根手指
I only have a finite number of fingers.

1082
00:48:24,825 --> 00:48:27,339
用我的老派计数方法 一根手指表示1
Using unary, my old school hashmark approach,

1083
00:48:27,340 --> 00:48:28,880
我用这只手可以数到5
I can count to five on this hand.

1084
00:48:28,883 --> 00:48:32,952
用二进制 我这只手可以数到31
Using binary, I claimed I could count to 31 on this hand.

1085
00:48:32,953 --> 00:48:34,149
但仍然是有限大的数字
But it's still finite.

1086
00:48:34,150 --> 00:48:37,835
因为我手指数量是有限的 所以我不能数到无穷大
I cannot count to infinity on this hand because I only have five fingers.

1087
00:48:37,836 --> 00:48:40,784
类似的 一台计算机只有数量有限的晶体管
Similarly does a computer only have so many transistors

1088
00:48:40,785 --> 00:48:43,803
或者大小有限的内存 所以一定程度上
or so many bytes or bits of memory, and at some point,

1089
00:48:43,804 --> 00:48:46,329
当用户想数到一个很大的数字
the programmer has to think about what is he

1090
00:48:46,330 --> 00:48:49,214
大到计算机无法存储时
or she going to do when the user wants to count so high that you

1091
00:48:49,215 --> 00:48:51,496
程序员需要考虑需要应该怎么处理
can't physically fit it anymore.

1092
00:48:51,497 --> 00:48:54,849
你不得不像这样放弃继续数数 用一个不精确的值来表示
You have to give up like this and say something semi accurately

1093
00:48:54,850 --> 00:48:58,451
或者用其他什么方式来解决这个问题
or you have to handle that issue in some other way.

1094
00:48:58,452 --> 00:49:01,736
后面我们会在C语言中看到你这个问题
And we'll see when we get to C that how you handle this problem is not

1095
00:49:01,737 --> 00:49:04,271
不一定会以直接的方式解决 而且相当多实际使用的软件
necessarily straightforward, and indeed a lot of software

1096
00:49:04,272 --> 00:49:06,402
没有很好的解决这个问题
out there does not handle this problem.

1097
00:49:06,403 --> 00:49:08,199
有可能我们都用这样使用软件的经历
And odds are, all of us have programs that if you

1098
00:49:08,200 --> 00:49:10,719
你在软件中输入了一个很长的词 或很大的数字
type big enough words or big enough numbers into them,

1099
00:49:10,720 --> 00:49:13,550
软件就出错 崩溃或者卡死了
they might very well break or crash or freeze

1100
00:49:13,551 --> 00:49:17,195
因为程序员 不像麻省理工学院 不总能预测到所有可能的情况
because the humans, unlike MIT, did not anticipate that that might actually

1101
00:49:17,196 --> 00:49:18,499
然后妥善的处理
happen and handle it.

1102
00:49:18,500 --> 00:49:19,746
我们继续
Well, let me go ahead and do this.

1103
00:49:19,747 --> 00:49:23,319
我打开这个程序 如果我们目前还不能读懂代码
Let me open up this program and see if we can't read the code now.

1104
00:49:23,320 --> 00:49:25,300
先把这个程序叫做Pet Zero
This is called Pet Zero

1105
00:49:25,860 --> 00:49:28,904
这是一个模拟撸猫的程序
and this is a program that simulates petting.

1106
00:49:28,905 --> 00:49:32,190
如果我点击开始后不碰键盘
So if I click play and don't touch the keyboard,

1107
00:49:32,191 --> 00:49:35,890
好像什么也没有发生 但如果我把鼠标指针移动到这只猫身上
nothing seems to be happening, but if I now move my cursor over to the cat...

1108
00:49:38,612 --> 00:49:39,161
还蛮可爱的
It's kind of cute.

1109
00:49:39,820 --> 00:49:43,352
现在这只猫只在你摸它的时候发出喵了
Right now, it's more only meowing on demand when you pet the cat.

1110
00:49:43,353 --> 00:49:44,020
为什么呢
Why?

1111
00:49:44,021 --> 00:49:46,179
好吧 可以看到我加了一些其他模块
Well, notice I've added some other building blocks.

1112
00:49:46,180 --> 00:49:48,719
我们以前可能没用到这个 但直觉上
We haven't used this one before, but it intuitively

1113
00:49:48,720 --> 00:49:50,169
应该也可以理解
probably makes pretty clear sense.

1114
00:49:50,170 --> 00:49:53,192
当点击绿色小旗后 一直执行下面的代码
When the green flag is clicked, forever do the following.

1115
00:49:53,193 --> 00:49:56,750
如果鼠标指针碰到小猫...这个蓝色的模块
If the cat is touching the mouse pointer... this thing in blue

1116
00:49:56,751 --> 00:49:58,619
我们先前讲到叫做布尔表达式
is what we called earlier a Boolean expression.

1117
00:49:58,620 --> 00:50:01,731
它算出一个是或否 真或假 1或0的答案
It has a yes/no, a true/false, a one/zero answer.

1118
00:50:01,732 --> 00:50:04,265
碰到鼠标指针是下拉菜单中的一个选项
And touching mouse pointer is one of the options in the little drop

1119
00:50:04,266 --> 00:50:05,634
点开就可以看到
down here if you tinker with it.

1120
00:50:05,635 --> 00:50:08,829
如果猫被鼠标指针碰到 仅当此刻
So if the cat is touching the mouse pointer, then and only then,

1121
00:50:08,830 --> 00:50:10,989
播放喵并等到结束
play sound meow until done.

1122
00:50:10,990 --> 00:50:14,739
所以我们把函数 循环和条件语句结合起来了
So we've combined now functions with loops with a condition.

1123
00:50:14,740 --> 00:50:16,097
但为什要用循环呢
But why the loop?

1124
00:50:16,870 --> 00:50:19,798
这只猫只在我摸它的时候发出喵
The cat's only meowing once when I pet him.

1125
00:50:19,930 --> 00:50:22,500
为什么我要用forever模块一直做这个呢
Why am I doing anything forever here?

1126
00:50:25,030 --> 00:50:26,403
有人吗...好
Someone... yeah.

1127
00:50:29,252 --> 00:50:29,766
对
Yeah.

1128
00:50:29,767 --> 00:50:33,449
我可能会再摸一次 我想让程序能响应未来的动作
I might want to pet it again, so I want the program to anticipate that.

1129
00:50:33,450 --> 00:50:37,019
如果我在程序中省略掉forever模块
And honestly, if I omitted this forever block and my program

1130
00:50:37,020 --> 00:50:39,600
让程序变成这个样子...
instead looked just like this...

1131
00:50:39,603 --> 00:50:41,429
所以让我跳过这些然后这个..
so let me get rid of that and this...

1132
00:50:41,430 --> 00:50:45,401
然后现在我点击运行 然后现在 我在他上面盘旋
and then I clicked play, and now, I hover over him,

1133
00:50:46,320 --> 00:50:48,504
为什么它一次都不运行呢
why is it not working even once?

1134
00:50:52,222 --> 00:50:53,297
请再说一遍
Say it again.

1135
00:50:57,419 --> 00:50:57,931
是的
Yeah.

1136
00:50:57,932 --> 00:50:59,867
所以我的意思是 在这一点上 如果我可以总结
So I mean, at this point, if I can summarize,

1137
00:50:59,868 --> 00:51:03,680
这个计算机太快了 以至于它已经运行完成了
the computer is so damn fast that this already

1138
00:51:03,683 --> 00:51:07,729
当我把鼠标挪到猫那里时他就发生 在那个时刻
happened by the time I moved my cursor over to the cat, and at the moment

1139
00:51:07,730 --> 00:51:10,759
我点了开始 我没有触碰那只猫
I clicked play, I was not touching the cat.

1140
00:51:10,760 --> 00:51:13,240
这些区块执行了 可以说 从开始到结束
Those blocks executed, so to speak, top to bottom.

1141
00:51:13,241 --> 00:51:14,553
这就是这个代码
That's it for the program.

1142
00:51:14,556 --> 00:51:17,619
所以当我把鼠标移到猫的那一刻 这个代码结束了
So by the time I move the cursor over to the cat, the program is over.

1143
00:51:17,620 --> 00:51:18,300
它没有在听
It's not listening.

1144
00:51:18,301 --> 00:51:22,033
永远都是这样 这是我为什么可以永远听到
And so forever, this way I can actually listen in perpetuity

1145
00:51:22,034 --> 00:51:23,849
实际发生的事情
for something to actually happen.

1146
00:51:23,850 --> 00:51:26,574
如果我想去做一些不仅仅是如果正确的事情
What if I want to do something not just if something is true,

1147
00:51:26,575 --> 00:51:27,718
而是去处理两种情况呢
but handle two cases?

1148
00:51:27,719 --> 00:51:28,879
“如果”或者“否则”
If or else.

1149
00:51:28,880 --> 00:51:31,200
嗯，让我门继续然后打开宠物一
Well, let me go ahead and open up Pet One.

1150
00:51:31,670 --> 00:51:33,409
这是另一个例子
And this is another example.

1151
00:51:33,410 --> 00:51:37,398
有没有人能够在看过代码后描述一下
And could someone perhaps describe, after reading this code,

1152
00:51:37,610 --> 00:51:40,403
这个代码即将替代性地做些什么
what this program is going to do instead?

1153
00:51:42,862 --> 00:51:43,697
对
Yeah.

1154
00:51:54,330 --> 00:51:54,840
完全正确
Exactly.

1155
00:51:54,841 --> 00:51:56,072
让我用更口语化的语言把它总结一下
And let me summarize more verbally.

1156
00:51:56,073 --> 00:52:00,054
所以这次 如果你触碰这只猫  它会滚动
So if this time, you're touching the cat, it's going to roar instead.

1157
00:52:00,055 --> 00:52:02,559
如果不是 它会很甜地喵喵叫
Else, it's just going to meow sweetly.

1158
00:52:02,560 --> 00:52:06,296
所以这次 一旦每一秒开始 它就会不停歇地喵喵叫
So this time, it is meowing perpetually once every second,

1159
00:52:06,297 --> 00:52:09,457
但是如果你触碰这只特殊的猫 它不会像这样
but if you touch this particular cat, it doesn't like it.

1160
00:52:09,458 --> 00:52:11,139
开始
So play.

1161
00:52:11,140 --> 00:52:12,045
喵
Meow.

1162
00:52:12,850 --> 00:52:13,899
喵
Meow.

1163
00:52:14,890 --> 00:52:15,900
然后现在
And now.

1164
00:52:16,860 --> 00:52:18,235
不要触碰这只猫
Don't touch the cat.

1165
00:52:18,236 --> 00:52:20,715
所以现在 我们可能在两个不同的方法上互相影响
So now, we might interact in two different ways

1166
00:52:20,716 --> 00:52:23,682
你有两种不同的可以走下去的方法
by having two different roads that you can go down.

1167
00:52:23,683 --> 00:52:26,099
嗯 我们在做一些更加交互性的东西
Well, let's actually make something a little more interactive.

1168
00:52:26,100 --> 00:52:28,169
让我继续打开下一个例子
Let me go ahead and open another example.

1169
00:52:28,170 --> 00:52:30,350
这是一个叫做Bounce Zero的模型因为现在
This one's called Bounce Zero because now,

1170
00:52:30,351 --> 00:52:34,190
我们可以开始从奥斯卡时间是什么开始看看设计元素
we can start to see some design elements from what Oscar Time was.

1171
00:52:34,191 --> 00:52:36,899
现在一点点变得有趣了
Like this now it's getting a little interesting.

1172
00:52:36,900 --> 00:52:38,856
现在发生了什么
What is actually going on here?

1173
00:52:38,857 --> 00:52:41,009
所以让我放大这里的区块
So let me zoom in on the blocks here.

1174
00:52:41,010 --> 00:52:44,519
这个区块是说永远向前移动10步
This block is just saying forever move 10 steps,

1175
00:52:44,520 --> 00:52:45,937
这是我们在另一个区块中没有看到的
which is another block we haven't seen.

1176
00:52:45,938 --> 00:52:47,494
但是10步就像10个像素
But 10 steps is like 10 pixels.

1177
00:52:47,495 --> 00:52:49,469
所以在屏幕上移动10个像素
So move 10 pixels on the screen.

1178
00:52:49,470 --> 00:52:52,771
但是如果你碰这个角，那么转180度
But if you're touching the edge, then turn around 180 degrees.

1179
00:52:52,772 --> 00:52:54,819
然后你可以看看到底发生了什么
And you can see exactly that happening.

1180
00:52:54,820 --> 00:52:58,120
抓取正在180度转 然后这个转圈
Scratch is turning around 180 degrees and this rotation style just

1181
00:52:58,121 --> 00:52:58,860
意味着两次后退
means double back.

1182
00:52:58,861 --> 00:53:01,294
不是像180度转圈
Don't like loop around 180 degrees.

1183
00:53:01,295 --> 00:53:02,514
这真的很酷
So that's kind of cool.

1184
00:53:02,515 --> 00:53:05,619
但这就是人或者猫是怎么走的
But this is not how humans or cats walk.

1185
00:53:05,620 --> 00:53:09,196
关于这个不是很明显的不自然吗
Like what is obviously unnatural about this?

1186
00:53:11,074 --> 00:53:11,486
是的
Yeah.

1187
00:53:11,487 --> 00:53:12,800
我的意思是 我的意思是 我甚至不能模仿他 是不是
I mean, I mean, I can't even simulate it, right?

1188
00:53:12,803 --> 00:53:17,079
就像他的腿在静态的姿势 但是可以实现在屏幕上向后和向前滑行
Like his feet are in static position, yet sliding back and forth on the screen.

1189
00:53:17,080 --> 00:53:18,699
然后 这不是在说走是什么
And yet, that is not what walking is.

1190
00:53:18,700 --> 00:53:21,550
就像走路大概有一些种类的动作然后呢
Like walking presumably has some kind of movement and what?

1191
00:53:21,551 --> 00:53:23,199
嗯 我们能够估计它就像...
Well, we could just kind of simulate it like...

1192
00:53:23,200 --> 00:53:24,729
好，我可以走路...
OK, I could just walk...

1193
00:53:24,730 --> 00:53:28,959
走路然后你可以想象给我的腿照快照
walking and you can imagine taking like really quick photographs of my legs

1194
00:53:28,960 --> 00:53:31,989
或者在猫的腿动的同时决定这个相片
or the cat's leg moving and then just deciding this photo

1195
00:53:31,990 --> 00:53:33,939
将会在一步中有代表性
will be representative of one step.

1196
00:53:33,940 --> 00:53:36,069
这张照片将代表另一个
This photo will be representative another.

1197
00:53:36,070 --> 00:53:38,323
然后你知道 在其中的两步下
And you know, with just two of those steps,

1198
00:53:38,324 --> 00:53:41,859
我打赌我们在预估方面做得很好
I'd wager we could actually do a pretty good job of simulating

1199
00:53:41,860 --> 00:53:43,049
走路看起来像什么
what walking looks like.

1200
00:53:43,050 --> 00:53:46,749
事实上 如果我们退回到开始的地方 抓取的这张图片
In fact, if I go back to where we began, this picture of Scratch,

1201
00:53:46,750 --> 00:53:51,200
如果把他的腿们轻轻的移走 然后再后退
what if I just move his legs ever so slightly, then go back,

1202
00:53:51,558 --> 00:53:52,691
再向前 会发生什么呢
then go forward?

1203
00:53:52,692 --> 00:53:56,652
甚至只在我的pdf文件中 我可以通过请求箭头记号来预估动画
And even just in my PDF, I can simulate animation by hitting up arrow,

1204
00:53:56,653 --> 00:53:58,579
箭头下降 箭头向上 箭头向下
down arrow, up arrow, down arrow

1205
00:53:58,580 --> 00:54:00,526
因为它看起来像他现在正在行走
because it kind of looks like he's walking now,

1206
00:54:00,527 --> 00:54:02,337
当 人眼一次次看到
when really, your human eyes are just seeing

1207
00:54:02,338 --> 00:54:04,753
2张不同的照片
two different pictures again and again.

1208
00:54:04,754 --> 00:54:05,832
所以我们该怎么办呢
So how can I do this?

1209
00:54:05,833 --> 00:54:08,889
嗯 如果我嫩回到抓取 他仍旧在走
Well, if I go back to Scratch, he's still walking.

1210
00:54:08,890 --> 00:54:13,902
让我去打开Bounce One 这个的第二个版本
Let me go ahead and open up Bounce One, the second version of this,

1211
00:54:15,099 --> 00:54:16,792
然后现在 做这个 and now, do this.

1212
00:54:16,793 --> 00:54:17,902
好
OK.

1213
00:54:19,206 --> 00:54:20,541
所以我该如何加上它 So how did I add this?

1214
00:54:20,542 --> 00:54:22,480
这有一些我们之前没有见过的紫色的区块
There's a little purple block that we haven't seen yet,

1215
00:54:22,483 --> 00:54:23,846
但是如果你从这个类中将其剔除
but if you poke around the categories,

1216
00:54:23,847 --> 00:54:26,045
你将在下一个服装中看到另外的区块
you'll see other blocks like this next costume

1217
00:54:26,046 --> 00:54:28,864
所以持续改变他正在穿的服装
that just keeps changing the costume that he's wearing.

1218
00:54:28,865 --> 00:54:32,536
结果为抓取作为一个图片和它的默认图片形式存在着
It turns out Scratch exists as a picture and his default picture

1219
00:54:32,537 --> 00:54:36,285
他没有在移动 但是如果我去到左上面然后点击服装
is him not moving, but if I go up here to top left and click costumes,

1220
00:54:36,286 --> 00:54:38,759
你实际上可以看到这里是他一个服装
you can actually see that here's his one costume.

1221
00:54:38,760 --> 00:54:40,472
这里是他的第二个服装
Here's his second costume.

1222
00:54:40,473 --> 00:54:43,193
这也是在下一个服装中的紫色区块
And so that purple block that says next costume,

1223
00:54:43,194 --> 00:54:45,174
因为它处在永久循环中
because it's in the forever loop,

1224
00:54:45,175 --> 00:54:47,736
它就一直持续不断的下一个 下一个 下一个 下一个 下一个
it just keeps doing next, next, next, next, next,

1225
00:54:47,737 --> 00:54:49,769
只是展示出一个服装或者是另一个
just showing one costume or the other.

1226
00:54:49,770 --> 00:54:52,749
他们都很清楚地在模仿走路
They're clearly mimicking walking.

1227
00:54:52,750 --> 00:54:54,179
现在，这不是很不自然了
Now, this is not very unnatural.

1228
00:54:54,180 --> 00:54:57,273
为什么我们不让他变慢 到一次五步
Why don't we slow him down to, say, five steps at a time

1229
00:54:57,746 --> 00:54:59,560
然后让他再走一遍
and have him go again?

1230
00:54:59,561 --> 00:55:01,227
现在 他依旧走的很快
Now, this is still going pretty fast.

1231
00:55:01,228 --> 00:55:03,779
让我继续
Let me go ahead and say...

1232
00:55:03,780 --> 00:55:05,549
我们应该拥有控制
we could have control.

1233
00:55:05,550 --> 00:55:09,320
我们应该让他在移动之后等一秒
We could have him wait a second after moving

1234
00:55:09,321 --> 00:55:11,408
非常显著地 very dramatically.

1235
00:55:11,640 --> 00:55:13,049
我们可以把它加速
We could probably speed this up.

1236
00:55:13,050 --> 00:55:16,000
所以让我们等0.1秒 0.1
So let's wait 1/10 of a second, 0.1.

1237
00:55:16,080 --> 00:55:19,331
或者我们来让它等0.01秒 一秒的百分之一
Or maybe let's do 0.01, 1/100 of a second.

1238
00:55:19,332 --> 00:55:20,971
现在 它一点点变得真实起来
Now, it's getting a little more realistic.

1239
00:55:20,972 --> 00:55:22,329
这就是动画是什么
But this is what animation is.

1240
00:55:22,330 --> 00:55:25,963
如果你曾经看过一个卡通片或者一个电影 是在像这样的图片的基础上
If you've ever watched a cartoon or a movie based on pictures like this,

1241
00:55:25,964 --> 00:55:29,069
你正在修补其中的一些参数 这些输入
you're just tinkering with some of these parameters, these inputs,

1242
00:55:29,070 --> 00:55:31,336
目的是通过理解去创造输出
in order to produce this output by understanding

1243
00:55:31,337 --> 00:55:34,264
这些东西最基础的代表是
what the fundamental representation of these things is,

1244
00:55:34,265 --> 00:55:37,382
在这些情况下是图片 一次 一次 又一次
which in this case are just pictures, again and again and again

1245
00:55:37,383 --> 00:55:39,239
目的是去创造动画
in order to create that animation.

1246
00:55:39,240 --> 00:55:40,920
但是交互性是怎样的呢
But what about interactivity?

1247
00:55:40,921 --> 00:55:42,029
让我来做一个
Let me do this one myself.

1248
00:55:42,030 --> 00:55:46,546
让我继续然后跳过这个 回到事件中 然后说
Let me go ahead and get rid of this, go back to events, and say,

1249
00:55:46,547 --> 00:55:48,209
当绿色旗帜被点击
when green flag clicked.

1250
00:55:48,210 --> 00:55:50,789
然后 让我向前然后抓住一个永久性的区块
Then, let me go ahead and grab a forever block

1251
00:55:50,790 --> 00:55:52,769
所以它一次次持续走
so that this keeps going again and again.

1252
00:55:52,770 --> 00:55:54,689
然后这时，让我向前去移动
And then, let me go ahead to go to motion.

1253
00:55:54,690 --> 00:55:57,809
在移动下 这里有一个我们之前没有看到过的区块
It turns out that under motion, there's this block we haven't seen...

1254
00:55:57,810 --> 00:55:59,879
被鼠标点击
point towards the mouse pointer.

1255
00:55:59,880 --> 00:56:02,189
让我继续然后把它拉到这里
And let me go ahead and pull this in here.

1256
00:56:02,190 --> 00:56:07,019
然后 让我以一次一步来移动它 而不是10
And then, let me have it move just like one step at a time, instead of 10.

1257
00:56:07,020 --> 00:56:10,099
它将要发生什么
What is this going to do?

1258
00:56:10,100 --> 00:56:11,704
这个代码是做什么的
What's this program do?

1259
00:56:13,231 --> 00:56:13,615
对 Yeah.

1260
00:56:13,616 --> 00:56:14,406
再说一次
Say it again.

1261
00:56:14,973 --> 00:56:15,792
跟着鼠标走
Follow the mouse.

1262
00:56:15,793 --> 00:56:15,975
对
Yeah.

1263
00:56:15,976 --> 00:56:20,605
这是一种带着你的猫走路的方法
This is kind of like a way of taking your cat for a walk.

1264
00:56:21,120 --> 00:56:25,494
可能不是我们打算的那种动物 但是他会跟随着鼠标
Perhaps not quite the animal we intended, but he'll follow the cursor.

1265
00:56:25,495 --> 00:56:27,709
然后我实际上可以一定程度上给他加速
And I can actually speed this up a little bit.

1266
00:56:27,710 --> 00:56:29,560
所以我们让他移动10步
So let's have him move 10 steps.

1267
00:56:29,561 --> 00:56:29,864
好
OK.

1268
00:56:29,865 --> 00:56:31,700
现在 让我们出发
Now, there we go.

1269
00:56:32,560 --> 00:56:35,499
所以现在 他正在上下移动 所以现在 他拥有交互性
So now, he's moving up and down, and so now, it's interactive.

1270
00:56:35,500 --> 00:56:39,470
所以你可能回忆到当我们在早些时候玩奥斯卡时间的时候 捡起...
So you might recall that when we were playing Oscar Time earlier and picking up...

1271
00:56:39,471 --> 00:56:41,112
好
OK.

1272
00:56:41,113 --> 00:56:41,586
别做它
Don't do that.

1273
00:56:41,587 --> 00:56:43,421
看 这是一个错误
See, that's a bug.

1274
00:56:43,422 --> 00:56:44,250
他刚才很犹疑
He's just confused.

1275
00:56:44,251 --> 00:56:46,199
他持续向前移动 但是你已经
He's constantly moving toward it, but you're already...

1276
00:56:46,200 --> 00:56:46,537
好
OK.

1277
00:56:46,538 --> 00:56:47,470
所以 我们要停下来了 So we're going to stop.

1278
00:56:47,470 --> 00:56:47,970
好
OK.

1279
00:56:47,971 --> 00:56:51,209
所以现在 他在追随 但是这是他现在该如何创造
So now, he's following, but that's how we might now create,

1280
00:56:51,210 --> 00:56:53,519
例如 把这些垃圾移走的能力
for instance, the ability to move those pieces of trash

1281
00:56:53,520 --> 00:56:55,489
然后让他们呢跟着鼠标的指向
around and have them follow the mouse cursor.

1282
00:56:55,490 --> 00:56:58,587
如果你从奥斯卡时间开始想 每次你捡起一片垃圾
If you think back to Oscar Time, every time you picked up a piece of trash,

1283
00:56:58,588 --> 00:57:01,915
他会跟随着鼠标因为这里是一个永久循环还有一个像这样的区块
he'd follow the cursor because there was a forever loop and a block like this

1284
00:57:01,916 --> 00:57:03,610
用鼠标指向他
pointing toward the mouse pointer.

1285
00:57:03,720 --> 00:57:06,299
嗯 现在 我们把几个想法汇合在一起
Well, now, let's integrate multiple ideas

1286
00:57:06,300 --> 00:57:08,083
然后实际上有很多脚本
and actually have multiple scripts.

1287
00:57:08,084 --> 00:57:12,779
我早些时候假设项目实际上可以有很多个线程
I proposed earlier that programs can actually have multiple threads.

1288
00:57:12,780 --> 00:57:16,319
一个线程是一个在我们课文中复杂的方式去解释多种脚本
A thread is just a fancy way of saying, in our context, multiple scripts.

1289
00:57:16,320 --> 00:57:21,720
一个项目中多个脚本在平行的发生
Multiple scripts in one program that are happening essentially in parallel.

1290
00:57:21,721 --> 00:57:25,155
因为线程设计 一个电脑可以在一次做很多事情
A computer can effectively do multiple things at a time thanks to threading,

1291
00:57:25,156 --> 00:57:26,659
然后在这条路径上下降的更多
and more on that down the road.

1292
00:57:26,660 --> 00:57:28,384
所以这些都包含其中 但是让我们看
So these are more involved, but let's see

1293
00:57:28,385 --> 00:57:30,649
如果我们可以...我们来首先理解这个项目干了什么
if we can... let's understand first what this program does.

1294
00:57:30,650 --> 00:57:31,857
让我继续然后命中开始
Let me go ahead and hit play.

1295
00:57:31,858 --> 00:57:34,093
这个可能有一些吵
And this one tends to be a little loud.

1296
00:57:38,605 --> 00:57:43,400
所以这个海上狮子在不停止 恼人地 叫
So the sea lion is just barking endlessly, annoyingly.

1297
00:57:43,401 --> 00:57:47,906
所以通过阅读代码 我怎么能让它不叫唤了呢
So by reading the code, how can I stop him from barking?

1298
00:57:49,190 --> 00:57:50,429
点击空格键
Hit the spacebar.

1299
00:57:50,430 --> 00:57:50,960
好了
All right.

1300
00:57:50,963 --> 00:57:52,900
所以击打空格键
So hit the spacebar.

1301
00:57:53,652 --> 00:57:54,274
好
OK.

1302
00:57:54,275 --> 00:57:56,291
我很明显可以停止这个程序了
I could just stop the program, obviously,

1303
00:57:56,292 --> 00:57:58,368
但是在技术上 这个程序实际上还是在运行
but this program is still running, technically.

1304
00:57:58,369 --> 00:57:59,809
但是为什么它还在工作
But why did that work?

1305
00:57:59,810 --> 00:58:02,839
嗯 注意这些在左手边的是第一个脚本
Well, notice this on the left hand side is the first script.

1306
00:58:02,840 --> 00:58:07,112
当绿色旗子被点击 设置这些变量我称作降低错误
When the green flag is clicked, set this variable that I called muted to false.

1307
00:58:07,113 --> 00:58:09,499
我们可以将其称之为x或者y或者相反的 他们中的一个都不要
Could have called it x or y or z or counter, but none of those

1308
00:58:09,500 --> 00:58:11,078
确实有意义 我称之为静音
really make sense, so I called it muted.

1309
00:58:11,079 --> 00:58:14,055
然后我把它设置为值为错误 它又是一个布尔变量
And I set it equal to false, which is, again, a Boolean value.

1310
00:58:14,056 --> 00:58:16,764
真或假的意思为是或否
True or false just mean yes or no.

1311
00:58:16,765 --> 00:58:20,333
永远 如果空格键被按下 就是在做这个
Forever, if the keyspace is pressed, then do this.

1312
00:58:20,334 --> 00:58:24,504
如果静音暂时错误 那么就把静音改为正确
If muted is currently false, then change muted to true.

1313
00:58:24,702 --> 00:58:27,192
否则 将静音改为错误
Else, change muted to false.

1314
00:58:27,193 --> 00:58:30,049
所以 如果静音是错误的 把它改为正确的
So if muted is false, change it to true.

1315
00:58:30,050 --> 00:58:32,379
如果静音是正确的 改为错误
If muted is true, change it to false.

1316
00:58:32,380 --> 00:58:36,342
任何时候人类点击了空格键 更新了这个变量
Any time the human hits the spacebar, update that variable.

1317
00:58:36,343 --> 00:58:40,039
现在 如果我们看其他脚本 也是驾驶海狮
Now, if we look at the other script, which is also driving the sea lion,

1318
00:58:40,040 --> 00:58:41,139
他在干什么 what is he doing?

1319
00:58:41,140 --> 00:58:44,141
永远 如果静音是错误 Forever, if muted is false.

1320
00:58:44,142 --> 00:58:45,403
所以如果他没有被静音 So if he's not muted.

1321
00:58:45,404 --> 00:58:47,459
如果静音是错误意味着没有被静音
If muted is false means not muted.

1322
00:58:47,460 --> 00:58:50,899
开始海狮的声音 然后想 你好 你好 你好 两秒
Start the sound sea lion and then think hi, hi, hi for two seconds,

1323
00:58:50,900 --> 00:58:52,699
然后多等一秒
and then wait for one more second.

1324
00:58:52,700 --> 00:58:54,439
然后重复 重复 重复
And then just repeat, repeat, repeat.

1325
00:58:54,440 --> 00:58:57,289
但是如果我用空格键将其改变 把静音改为正确
But if I change with the spacebar muted to true,

1326
00:58:57,290 --> 00:59:00,739
他将会说 如果静音是错误的 这不是这样的
he's going to say if muted equals false, that's not so.

1327
00:59:00,740 --> 00:59:02,381
我这次不是将要发出一个声音
I'm not going to play a sound this time.

1328
00:59:02,382 --> 00:59:05,942
所以现在 我们有了能力去将多种脚本整合在一起
And so now, we have the ability to integrate multiple scripts together

1329
00:59:05,943 --> 00:59:08,929
以达成完成一个更有交互性的结果的目的
in order to achieve a more interactive result.

1330
00:59:08,930 --> 00:59:10,259
那么这个如何呢
And what about this?

1331
00:59:10,260 --> 00:59:16,169
回到我是个孩子的时候 有可能之前玩夏天马可波罗
Back when I was a kid, might have played in the summers Marco Polo.

1332
00:59:16,170 --> 00:59:17,479
非常简单的游戏 Super simple game.

1333
00:59:17,480 --> 00:59:19,051
我们在池中开始 因为一些原因
We played it in the pool, for some reason,

1334
00:59:19,052 --> 00:59:21,379
池中的很安全的人是被蒙住眼睛的
where one person in the pool very safely is blindfolded,

1335
00:59:21,380 --> 00:59:23,089
然后这是他或她大喊Macro
and then he or she yells Marco.

1336
00:59:23,090 --> 00:59:26,402
然后这时 每一个在他或她旁边的人都喊macro
And then, everyone around him or her is supposed to yell polo.

1337
00:59:26,403 --> 00:59:27,799
然后这时 蒙住眼睛的那个人
And then, the person who's blindfolded is

1338
00:59:27,800 --> 00:59:30,079
有可能去追上其他的孩子然后给他们贴上标签
supposed to go chase the other kids in the pool and tag them,

1339
00:59:30,080 --> 00:59:31,189
然后这时他们成为它 and then they become it.

1340
00:59:31,190 --> 00:59:33,559
但是换句话说 这就像给机器打信号
But in other words, it's this like signaling mechanism.

1341
00:59:33,560 --> 00:59:36,304
有些人喊Macro 然后其他的所有人回应
Someone yells, Marco and everyone else responds

1342
00:59:36,305 --> 00:59:38,719
就像Macro这个单词的广播
to that broadcast of the word Marco.

1343
00:59:38,720 --> 00:59:41,449
嗯 结果是我们可以通过这两个受操纵的人估计
Well, it turns out we can simulate this with these two puppets.

1344
00:59:41,450 --> 00:59:44,392
这些人 注意到我给橙色的木偶重点标记
This guy here... notice that I've highlighted the orange puppet

1345
00:59:44,393 --> 00:59:45,971
因为这里有一秒蓝色的木偶
because there's a second blue puppet there.

1346
00:59:45,972 --> 00:59:46,760
分离妖精 Separate sprites.

1347
00:59:46,761 --> 00:59:49,870
这些就是我们给这个游戏上传的图片
And these are just photographs we uploaded to the game.

1348
00:59:49,871 --> 00:59:54,350
永远 如果空格键被按下 所以如果空格键被按下
Forever, if the key space is pressed, so if the spacebar is pressed,

1349
00:59:54,351 --> 00:59:57,829
两秒钟说Macro 然后广播这个事件
say Marco for two seconds and then broadcast an event.

1350
00:59:57,830 --> 01:00:02,969
同时 蓝色的木偶有一个很简单的区块
Meanwhile, the blue puppet here has a super simple block,

1351
01:00:02,970 --> 01:00:05,261
但是这和我们已经看到的在基础上就不一样
but it's fundamentally different from the ones we've seen.

1352
01:00:05,262 --> 01:00:08,119
当绿色旗帜被标注时他没有开始
He's not starting when the green flag is clicked.

1353
01:00:08,120 --> 01:00:11,269
只有当他接收到一个事件时 他才开始
He is starting only when he receives an event.

1354
01:00:11,270 --> 01:00:14,072
所以结果是妖精和抓取不能看到或者听到
So it turns out that sprites and Scratch can't hear or see

1355
01:00:14,073 --> 01:00:16,206
另一个所说的是在这些说话泡泡中
what the other one is saying in those speech bubbles.

1356
01:00:16,207 --> 01:00:17,824
你只能去用一个更好的技术
You have to use a fancier technique,

1357
01:00:17,825 --> 01:00:19,815
是一个特殊的区块名叫广播
which is the special block called broadcast,

1358
01:00:19,816 --> 01:00:23,971
譬如说像是在数码世界里一个小精灵给另一个小精灵传递字条
which is like passing a note digitally from one sprite to another

1359
01:00:23,972 --> 01:00:26,749
另一个才能够阅读或收到
that the other one can read or receive, so to speak.

1360
01:00:26,750 --> 01:00:29,005
譬如 只有当他收到这个事件
So only when he receives this event, so to speak,

1361
01:00:29,006 --> 01:00:31,339
他才会说2秒钟的波罗
does he say polo for two seconds.

1362
01:00:31,340 --> 01:00:35,101
再一次 橙色人偶发送了这个秘密信息
And again, the orange puppet sends that secret message

1363
01:00:35,102 --> 01:00:36,406
用的是另一块拼图
just using this other puzzle piece.

1364
01:00:36,407 --> 01:00:41,014
像传递了一个人类看不见的纸条一样 广播了一个事件
Broadcast an event, like passing a note that the human doesn't actually see.

1365
01:00:41,015 --> 01:00:45,968
所以如果我现在点击小绿旗和空格键 橙色人偶便大喊马可
So if I now hit the green flag and hit the spacebar, orange yells Marco.

1366
01:00:45,969 --> 01:00:48,931
蓝色人偶回应波罗
Blue guy yells polo in response.

1367
01:00:48,932 --> 01:00:50,809
但他们并不是同时发生的
But those aren't timed together.

1368
01:00:50,810 --> 01:00:54,267
而是只有当蓝色人偶听到橙色人偶说过之后
Rather, the blue guy is hearing with the orange one has said,

1369
01:00:54,268 --> 01:00:59,219
从而才真正允许多个小精灵互相交流
thereby allowing multiple sprites to actually intercommunicate.

1370
01:00:59,220 --> 01:01:00,365
所以我们是如何做到这些的呢
So how did we get here?

1371
01:01:00,366 --> 01:01:03,821
回忆一下我们刚才有的所有构造块
Well, recall that we had all of these building blocks a moment ago.

1372
01:01:03,822 --> 01:01:05,817
首先 我们从函数和条件开始
First, we started out with just functions and conditions

1373
01:01:05,818 --> 01:01:07,249
还有布尔表达式和循环
and Boolean expressions and loops.

1374
01:01:07,250 --> 01:01:09,579
现在我们已经增加了在变量中存储信息的能力
We've now added to that the ability to store information

1375
01:01:09,580 --> 01:01:12,461
还有可以同时做多任务的线程
in variables and threads to do multiple things at once,

1376
01:01:12,462 --> 01:01:15,403
接着 如果你正在进行多任务
and then, if you do have multiple things happening, events, where

1377
01:01:15,404 --> 01:01:17,719
通过事件 可以使它们以某种方法进行交流
they can enter communicate somehow.

1378
01:01:17,720 --> 01:01:19,069
那又是另一个构造块了
Yet another building block.

1379
01:01:19,070 --> 01:01:22,212
所以如果我们现在退一步想
So if we now take a step back and consider

1380
01:01:22,213 --> 01:01:25,619
我们如何靠自己去构造函数呢
how we can make functions of our own,

1381
01:01:25,620 --> 01:01:28,419
比如说 我们有最后一块拼图
we have the final piece of the puzzle, so to speak.

1382
01:01:28,420 --> 01:01:29,629
让我接着往下做
Let me go ahead and do this.

1383
01:01:29,630 --> 01:01:34,039
让我继续创建一个简单的程序 放好小绿旗
Let me go ahead and create a simple program with, when green flag clipped,

1384
01:01:34,040 --> 01:01:36,146
这可以简单的模仿猫的咳嗽
that simply simulates coughing for a cat.

1385
01:01:36,147 --> 01:01:41,299
所以这只猫将咳嗽1秒 而不是说你好
So this cat is going to say not hello, but cough for one second.

1386
01:01:41,300 --> 01:01:45,079
接着它将继续等待1秒钟
And then he's going to go ahead and wait for one second.

1387
01:01:45,080 --> 01:01:48,805
然后我会像之前那样复制粘贴...
And then I'm going to go ahead and copy paste, as I did before...

1388
01:01:48,806 --> 01:01:52,579
这属于一种我真这样说 但不该真这样做的方法...
this is one of those do as I say, not as I do... to implement this program here,

1389
01:01:52,580 --> 01:01:54,691
为了去实现它咳嗽3次的程序
where he coughs three times.

1390
01:01:54,692 --> 01:01:57,559
我们之前就知道了 这算不上一个好的设计
We already know, though, from earlier that this is not good design.

1391
01:01:57,560 --> 01:01:58,500
为什么呢
Why?

1392
01:02:00,083 --> 01:02:01,099
你这是在重复你自己
You're repeating yourself.

1393
01:02:01,100 --> 01:02:02,683
不要重复你自己
Don't repeat yourself.

1394
01:02:02,684 --> 01:02:04,169
实际上 DRY是一个首字母缩写
DRY is an acronym, actually.

1395
01:02:04,170 --> 01:02:05,950
不要重复你自己 因为你正在做三次
Don't repeat yourself because you're doing

1396
01:02:05,951 --> 01:02:09,879
原本只需你真正做一次的事情
three times as many times something that you only really need to do once.

1397
01:02:09,880 --> 01:02:13,144
当然 之前的解决方法是使用某一种循环
The solution before, of course, was just use a loop of some sort.

1398
01:02:13,145 --> 01:02:14,740
所以让我把它实际拿出来
So let me actually take that out.

1399
01:02:14,744 --> 01:02:18,669
让我使用一个重复块 把10改成3
Let me use a repeat block, change 10 to three,

1400
01:02:18,670 --> 01:02:20,371
然后仅仅用到其中的2个构造块
and then just use two of these blocks.

1401
01:02:20,372 --> 01:02:22,689
注意到了吧 程序简洁了许多
And notice already, the program is so much more compact.

1402
01:02:22,690 --> 01:02:27,579
现在 假如我想把3改为10或30 或者任何数字
And now, if I want to change the three to a 30 or to a 10 or any number,

1403
01:02:27,580 --> 01:02:29,119
我仅需改变一个简单的值
I just change one simple value.

1404
01:02:29,120 --> 01:02:32,379
我不需要去重新写或复制粘贴 或者删除它们
I don't have to rewrite or copy paste or delete things.

1405
01:02:32,380 --> 01:02:34,406
我可以更容易地去更新程序
I can update the program much more readily,

1406
01:02:34,407 --> 01:02:39,700
现在 相同的事情也会发生在咳 咳 咳上
and now, the same thing is going to happen with just cough, cough, cough.

1407
01:02:39,910 --> 01:02:44,049
但事实证明 今后把它从中抽象出来才好 对吧
But it turns out that it would be nice to henceforth abstract away from this, right?

1408
01:02:44,050 --> 01:02:47,499
我只想让我写每个的程序都知道 如何去咳嗽
I just want any program I write to know how to cough.

1409
01:02:47,500 --> 01:02:49,501
咳嗽确实能表达某些东西
And coughing is really just saying something,

1410
01:02:49,502 --> 01:02:50,982
也许是某个次数
perhaps some number of times.

1411
01:02:50,983 --> 01:02:53,649
但事实证明 我们可以在代码中把它抽象出来
But it turns out we can abstract this away in code.

1412
01:02:53,650 --> 01:02:55,854
让我来到我的模块这儿
Let me go down to My Blocks here

1413
01:02:55,855 --> 01:02:58,301
这使我能点击这个按钮...建造模块
and this allows me to click this button... Make a Block.

1414
01:02:58,302 --> 01:02:59,960
使我能建造我自己的函数
It allows me to make my own function.

1415
01:02:59,961 --> 01:03:01,659
在这里我有这个对话框
I get this dialog window here.

1416
01:03:01,660 --> 01:03:04,389
我将把这个块叫做咳嗽
And I'm just going to call this block cough.

1417
01:03:04,390 --> 01:03:06,294
我将继续点击OK按钮
I'm going to go ahead and click OK.

1418
01:03:06,295 --> 01:03:10,520
现在 我有了这个可以在其下构建块的新粉色模块
And now, I have this new pink block that itself can have blocks underneath it.

1419
01:03:10,521 --> 01:03:11,396
你知道我要做什么吗
And you know what I'm going to do?

1420
01:03:11,397 --> 01:03:12,861
我要继续做这个
I'm going to go ahead and do this.

1421
01:03:12,862 --> 01:03:17,109
我将继续把咳嗽放在下面
I'm going to go ahead and say cough under there.

1422
01:03:17,110 --> 01:03:20,799
现在 注意左边 我可以使用这个新粉色块了
And now, notice on the left, I now have access to this new pink piece.

1423
01:03:20,800 --> 01:03:22,664
我现在可以把它放到这儿
I can now put this in here.

1424
01:03:22,665 --> 01:03:27,009
所以现在注意 这就是咳嗽如何被实现的
So now, notice even though, yes, this is how coughing is implemented

1425
01:03:27,010 --> 01:03:30,777
在左手边这里 下一次当我要写程序的时候
on the left hand side here, next time, when I write a program,

1426
01:03:30,778 --> 01:03:32,621
我想只说 咳嗽
I just want to call cough.

1427
01:03:32,622 --> 01:03:35,169
我不在乎那些底层实现的细节
And I don't care about those lower level implementation details.

1428
01:03:35,170 --> 01:03:36,820
我连派对什么的都不在乎
I don't care about the party or any of that.

1429
01:03:36,824 --> 01:03:38,812
我只希望让它变成一个抽象
I just want this to be an abstraction.

1430
01:03:38,813 --> 01:03:41,075
但是我可以比这做得更好
But I could do better than this wouldn't it

1431
01:03:41,076 --> 01:03:44,169
如果不用重复三次咳嗽 是否会变得更好呢
be nice if instead of just repeating cough three times,

1432
01:03:44,170 --> 01:03:46,209
如果我把它做为咳嗽的一种特征
what if I made that a feature of cough?

1433
01:03:46,210 --> 01:03:47,200
让我来这样做
So let me do this.

1434
01:03:47,203 --> 01:03:51,549
我可以继续点击这个粉色块 并且编辑它
I can go ahead and right click on this pink piece and I can edit it.

1435
01:03:51,550 --> 01:03:53,529
就会出现和之前同样的窗口
That brings up that same window from before.

1436
01:03:53,530 --> 01:03:54,250
注意看这里
And notice this.

1437
01:03:54,251 --> 01:03:55,519
添加一个输入
Add an input.

1438
01:03:55,520 --> 01:03:58,805
所以当我制作一个自定义块的时候 我实际上可以做的非常精致
So when I make a custom block, I can actually make pretty fancy blocks

1439
01:03:58,806 --> 01:04:02,109
就像是麻省理工学院给我们的软件一样
just like the ones MIT gives us with the software,

1440
01:04:02,110 --> 01:04:04,239
现在 我可以输入一些东西 比如 n
and now, I can type in something like n.

1441
01:04:04,240 --> 01:04:07,599
如果为了更好地描述而添加一个标签 我可以叫它次数
And if I add a label just to make it more descriptive, I can just say times.

1442
01:04:07,600 --> 01:04:09,929
所以现在 我已经做好了一个特殊的自定义拼图
So now, I've made a special custom puzzle piece

1443
01:04:09,930 --> 01:04:13,419
它表明咳嗽某多次 n代表的是次数
that says cough some number of times, where n for number

1444
01:04:13,420 --> 01:04:16,879
是一个程序员常用的变量名
is just the go to variable that programmers tend to use.

1445
01:04:16,880 --> 01:04:24,739
所以现在 我实际上可以把这个重复块移到咳嗽本身里面
So now, I can actually move this repeat block into cough itself,

1446
01:04:24,740 --> 01:04:26,824
但不要用数字3 看这儿
but rather than hard code 3, notice this.

1447
01:04:26,825 --> 01:04:31,999
我可以偷用这个变量 通过重复
I can steal that variable and now say cough this many times by repeating

1448
01:04:32,000 --> 01:04:35,169
让它咳嗽咳嗽再咳嗽
saying this again and again and again.

1449
01:04:35,170 --> 01:04:40,419
现在 当想让我的实际程序咳嗽时 我只需在这输入3
And now, when I cough in my actual program, I just type in three here.

1450
01:04:40,420 --> 01:04:42,889
所以我现在有了这个美丽的抽象 打个比方说
So I have this beautiful abstraction now, so to speak.

1451
01:04:42,890 --> 01:04:46,029
要让它咳嗽这么多次 我和世界上每个人
Cough this many times and I and no one else in the world

1452
01:04:46,030 --> 01:04:48,472
都不再需要关心怎么去咳嗽了
never again needs to care about what it means to cough

1453
01:04:48,473 --> 01:04:50,765
因为我们早已实现了它
because we've already implemented that before.

1454
01:04:50,766 --> 01:04:53,414
正如麻省理工学院为已经我们提供了如此多的功能
And so just as MIT has given us so much functionality

1455
01:04:53,415 --> 01:04:55,479
我们不用自己去构思
that we ourselves don't have to think about, so can

1456
01:04:55,480 --> 01:04:58,099
所以我现在构造功能时不用去想其他的
I now make functionality that I don't have to think about.

1457
01:04:58,100 --> 01:05:01,101
随着我们提升到高级语言 如 C 语言和 JavaScript
And as we progress to higher level languages like C and JavaScript

1458
01:05:01,102 --> 01:05:03,377
还有Python 我们会继续这个过程
and Python, we're going to continue this process, sometimes

1459
01:05:03,378 --> 01:05:06,999
有时候我们通过做自定义块去解决问题
solving problems ourselves by making our own custom puzzle pieces,

1460
01:05:07,000 --> 01:05:09,230
但更通常来说 我们会用叫做库的东西
but very often using things called libraries,

1461
01:05:09,231 --> 01:05:13,599
其他人之前写好的代码 对工作来讲非常有用
code that other humans wrote before us that's just useful to get the job done,

1462
01:05:13,600 --> 01:05:17,389
就像 Scratch 在这里为我们做的部分一样
just as Scratch has done here in part for us.

1463
01:05:17,390 --> 01:05:21,112
让我继续 接着把所有东西汇总
Let me go ahead, then, and bring all of this together

1464
01:05:21,113 --> 01:05:23,906
在这儿打开另一个例子
by opening this other example here.

1465
01:05:24,166 --> 01:05:27,912
让我继续打开这一个 这是我们之前没看过的东西
Let me go ahead and open up this one, which isn't something we've seen,

1466
01:05:27,913 --> 01:05:32,173
但这是一个之前学生做的互动游戏
but it's kind of an interactive game like this made by a former student.

1467
01:05:36,080 --> 01:05:37,329
我们要一个苹果吗
Should we have an apple?

1468
01:05:37,330 --> 01:05:38,594
是的
Yes.

1469
01:05:39,833 --> 01:05:41,300
经过一点点动画
A little animation.

1470
01:05:44,904 --> 01:05:45,460
好吧
OK.

1471
01:05:45,461 --> 01:05:46,864
这还没有结束
That didn't end well.

1472
01:05:46,865 --> 01:05:48,309
让我们再试一次
Let's try again.

1473
01:05:48,310 --> 01:05:49,499
再玩一次
Play again.

1474
01:05:50,200 --> 01:05:52,544
注意出现了对话块
And notice the say block is happening.

1475
01:05:52,545 --> 01:05:54,574
是某种询问块
There's some kind of ask block.

1476
01:05:54,575 --> 01:05:57,369
学生制作者想查看是否用户输入 yes 或者 no
The student was checking if the human typed in yes or no.

1477
01:05:57,370 --> 01:05:58,281
让我们这次输入 no
Let's type no this time.

1478
01:05:58,282 --> 01:05:59,341
不要苹果
No apple.

1479
01:05:59,342 --> 01:06:00,280
喔 纸杯蛋糕
Ooh. Cupcake.

1480
01:06:00,281 --> 01:06:01,491
好吧 Yes
OK. Yes.

1481
01:06:01,492 --> 01:06:02,598
回车进入
Enter.

1482
01:06:07,293 --> 01:06:08,552
好吧
OK.

1483
01:06:08,553 --> 01:06:09,805
不要这样做
Don't do that.

1484
01:06:10,219 --> 01:06:10,960
再玩一条命
One more life.

1485
01:06:10,963 --> 01:06:12,201
开始
Here we go.

1486
01:06:13,982 --> 01:06:14,313
好的
OK.

1487
01:06:14,314 --> 01:06:15,801
不要苹果
No apple.

1488
01:06:16,130 --> 01:06:17,603
不要纸杯蛋糕
No cupcake.

1489
01:06:19,568 --> 01:06:21,499
几乎没啥变化
Little variable.

1490
01:06:29,510 --> 01:06:30,093
好吧
OK.

1491
01:06:30,094 --> 01:06:32,000
所以我赢了游戏
So I won the game.

1492
01:06:33,120 --> 01:06:38,472
在我们的最后时刻 让我继续打开最后一个例子
In our final moments here, let me go ahead and open one final example.

1493
01:06:38,473 --> 01:06:42,590
如你所知 CS50 不仅在哈佛 还在耶鲁提供
As you know, CS50 is offered not only at Harvard, but at Yale, as well,

1494
01:06:42,591 --> 01:06:44,400
所以似乎比较适合以传递一张纸条结束
so it seems fitting to perhaps end on a note that

1495
01:06:44,403 --> 01:06:47,904
在另一个游戏里也许会使一个学校对阵另一个
pits one campus perhaps against the other by way of another game

1496
01:06:47,905 --> 01:06:50,649
一位之前的学生写的 名为常春藤最难的游戏
that a former student wrote called Ivy's Hardest Game.

1497
01:06:50,650 --> 01:06:54,172
但对此来说 我觉得我们需要最后一位志愿者上前
But for this, I think we need one final volunteer who's company coming up.

1498
01:06:54,173 --> 01:06:54,553
好的
OK.

1499
01:06:54,553 --> 01:06:55,022
第一个举手的
First hand.

1500
01:06:55,022 --> 01:06:55,690
就在那儿
Right there.

1501
01:06:55,691 --> 01:06:56,998
下来吧
Come on down.

1502
01:06:57,575 --> 01:07:01,125
所以在常春藤最难的游戏里 它是用键盘玩的
So in Ivy's Hardest Game, it's a game played with the keyboard.

1503
01:07:01,126 --> 01:07:03,571
虽然它乍看上去有一点令人不知所措
And even though it might look a little overwhelming at first glance,

1504
01:07:03,572 --> 01:07:06,849
就像奥斯卡和姜饼动画一样
just like Oscar Time did and just like the gingerbread animation might,

1505
01:07:06,850 --> 01:07:09,992
请意识到如果你在脑海里解构它
realize that if you decompose it in just your mind's eye thinking about what

1506
01:07:09,993 --> 01:07:12,377
思考它单独的模块是什么 你也许
those individual building blocks are, you can probably

1507
01:07:12,378 --> 01:07:13,729
可以猜到用的是什么拼图
guess what the puzzle pieces are.

1508
01:07:13,730 --> 01:07:14,502
嗨 你的名字是
Hi. What's your name?

1509
01:07:14,503 --> 01:07:15,131
嗨 我是安德里亚
Hi. I'm Andrea.

1510
01:07:15,132 --> 01:07:15,520
安德里亚
Andrea.

1511
01:07:15,521 --> 01:07:16,840
大卫 很高兴遇见你
David. Nice to meet you.

1512
01:07:16,841 --> 01:07:19,102
这是常春藤最难的游戏
Here is Ivy's Hardest Game.

1513
01:07:20,626 --> 01:07:23,039
让你在此和对阵所有的藤校
Pits you against all of the Ivies here.

1514
01:07:23,040 --> 01:07:27,192
在这结束之后 我们去教堂休息吃纸杯蛋糕
And then right after this will we adjourn for cupcakes in the transept.

1515
01:07:27,193 --> 01:07:28,299
准备好了吗
Ready?

1516
01:07:32,006 --> 01:07:34,699
[音乐 -MC汉默 “你不能碰”]
[MUSIC - MC HAMMER, "U CAN'T TOUCH THIS"]

1517
01:07:36,987 --> 01:07:43,480
♪ You can't touch this. ♪

1518
01:07:44,302 --> 01:07:45,213
好的
Nice.

1519
01:07:45,214 --> 01:07:46,979
♪ You can't touch this. ♪

1520
01:07:46,980 --> 01:07:48,999
♪ My, my, my, my. ♪

1521
01:07:49,000 --> 01:07:50,789
♪ Music hits you so hard. ♪

1522
01:07:50,790 --> 01:07:52,789
♪ Makes me say, oh my lord. ♪

1523
01:07:52,790 --> 01:07:56,279
♪ Thank you for blessing me with a mind to rhyme and two hype feet. ♪

1524
01:07:56,280 --> 01:07:58,189
♪ It feels good when you know you're down. ♪

1525
01:07:58,190 --> 01:07:59,779
♪ A super dope homeboy from the Oaktown. ♪

1526
01:07:59,780 --> 01:08:01,769
♪ And I'm known as such. ♪

1527
01:08:01,770 --> 01:08:04,769
♪ And this is the beat you can't touch. ♪

1528
01:08:04,770 --> 01:08:08,009
♪ I told you, homeboy, you can't touch this. ♪

1529
01:08:08,010 --> 01:08:08,897
♪ Yeah. ♪

1530
01:08:08,898 --> 01:08:11,749
♪ That's how we're living and you know you can't touch this. ♪

1531
01:08:11,750 --> 01:08:12,750
♪ Look in my eyes. ♪

1532
01:08:12,751 --> 01:08:15,250
♪ Man, you can't touch this. ♪

1533
01:08:17,910 --> 01:08:19,739
♪ Fresh new kicks and pants. ♪

1534
01:08:19,740 --> 01:08:22,069
♪ You got it like that and now you know you want to dance. ♪

1535
01:08:22,070 --> 01:08:24,059
♪ So move out of your seat and get a fly girl ♪

1536
01:08:24,060 --> 01:08:26,219
♪ and catch this beat while it's rolling. ♪

1537
01:08:26,220 --> 01:08:26,720
♪ Hold on. ♪

1538
01:08:26,721 --> 01:08:29,719
♪ Pump a little bit and let me know it's going on like that. ♪

1539
01:08:29,720 --> 01:08:30,710
♪ Like that. ♪

1540
01:08:30,711 --> 01:08:32,209
♪ Cold on a mission so pull on back. ♪

1541
01:08:32,210 --> 01:08:37,199
♪ Let them know that you're too much and this is the beat you can't touch. ♪

1542
01:08:37,200 --> 01:08:41,189
♪ Yo, I told you, you can't touch this. ♪

1543
01:08:41,190 --> 01:08:42,689
♪ Why you standing there, man? ♪

1544
01:08:42,690 --> 01:08:43,690
♪ You can't touch this. ♪

1545
01:08:43,691 --> 01:08:45,189
♪ Yo, sound the bells. ♪

1546
01:08:45,190 --> 01:08:46,180
♪ School is in, sucker. ♪

1547
01:08:46,180 --> 01:08:47,060
♪ You can't touch this. ♪

1548
01:08:47,061 --> 01:08:48,679
♪ Give me a song or rhythm. ♪

1549
01:08:48,680 --> 01:08:49,430
♪ Making them sweat. ♪

1550
01:08:49,431 --> 01:08:50,669
♪ That's what I'm giving them. ♪

1551
01:08:50,670 --> 01:08:53,169
♪ Now they know when you talk about the Hammer, ♪

1552
01:08:53,170 --> 01:08:55,659
♪ you talking about a show that's hyped and tight. ♪

1553
01:08:55,660 --> 01:08:58,659
♪ Singers are sweating so pass them a wipe or a tape ♪

1554
01:08:58,660 --> 01:09:01,929
♪ to learn what it's going to take in the 90s to burn the charts. ♪

1555
01:09:01,930 --> 01:09:03,471
♪ Second to last level. ♪

1556
01:09:03,850 --> 01:09:06,509
♪ Either work hard or you might as well quit. ♪

1557
01:09:06,510 --> 01:09:11,349
♪ That's word because you know you can't touch this. ♪

1558
01:09:11,350 --> 01:09:14,849
♪ You can't touch this. ♪

1559
01:09:14,850 --> 01:09:15,850
♪ Break it down. ♪

1560
01:09:28,850 --> 01:09:29,350
♪ Stop. ♪

1561
01:09:29,350 --> 01:09:30,350
♪ Hammer time. ♪

1562
01:09:30,351 --> 01:09:31,549
♪ Go with the flow, it is said. ♪

1563
01:09:31,550 --> 01:09:33,889
♪ If you can't groove to this, then you probably are dead. ♪

1564
01:09:33,890 --> 01:09:35,349
♪ So wave your hands in the air. ♪

1565
01:09:35,350 --> 01:09:36,350
♪ Bust a few moves. ♪

1566
01:09:36,351 --> 01:09:37,799
♪ Run your fingers through your hair. ♪

1567
01:09:37,800 --> 01:09:38,929
♪ This is it for a winner. ♪

1568
01:09:38,930 --> 01:09:40,849
♪ Dance to this and you're going to get thinner. ♪

1569
01:09:40,850 --> 01:09:41,850
♪ Move. ♪

1570
01:09:41,850 --> 01:09:42,850
♪ Slide your rump. ♪

1571
01:09:42,851 --> 01:09:46,349
♪ Just for a minute, let's all do the bump, bump, bump. ♪

1572
01:09:46,350 --> 01:09:47,350
♪ Yeah. ♪

1573
01:09:47,351 --> 01:09:49,849
♪ You can't touch this. ♪

1574
01:09:49,850 --> 01:09:50,850
♪ Look, man. ♪

1575
01:09:50,851 --> 01:09:52,849
♪ You can't touch this. ♪

1576
01:09:52,850 --> 01:09:54,850
♪ You better get hype, boy, because you know... ♪

1577
01:09:58,470 --> 01:10:00,850
♪ Break it down. ♪

1578
01:10:05,833 --> 01:10:06,998
没事 没关系
No. It's OK.

1579
01:10:10,671 --> 01:10:11,801
♪ One more life. ♪

1580
01:10:11,850 --> 01:10:12,929
♪ Stop. ♪

1581
01:10:12,930 --> 01:10:13,624
♪ Hammer time. ♪

1582
01:10:19,485 --> 01:10:19,975
好吧
All right.

1583
01:10:19,976 --> 01:10:22,295
如果可以的话请为安德里亚鼓掌
A round of applause for Andrea, if we could.

1584
01:10:24,946 --> 01:10:26,086
好了
OK.

1585
01:10:26,563 --> 01:10:28,249
这就是 CS50
That's it for CS50.

1586
01:10:28,250 --> 01:10:29,529
去网页查看详情
See the website for details.

1587
01:10:29,530 --> 01:10:31,629
我们在教堂吃蛋糕见
We'll see you for cake in the transept.

1588
01:10:31,630 --> 01:10:33,102
欢迎加入
Welcome aboard.

